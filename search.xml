<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【问题解决】vscode上go的自动补全和跳转</title>
    <url>/2021/04/27/vscode%E4%B8%ADgo/</url>
    <content><![CDATA[<h1 id="vscode上go自动补全问题和跳转问题"><a href="#vscode上go自动补全问题和跳转问题" class="headerlink" title="vscode上go自动补全问题和跳转问题"></a>vscode上go自动补全问题和跳转问题</h1><p><em><strong>在UOS环境下用vscode，不能跳转和自动补全。</strong></em></p>
<span id="more"></span>
<h2 id="ctrl不能跳转"><a href="#ctrl不能跳转" class="headerlink" title="ctrl不能跳转"></a>ctrl不能跳转</h2><p>解决：</p>
<ol>
<li>settings-&gt;搜索 use language server</li>
</ol>
<p>-&gt;Go: Use Language Server 改为非选中状态,就可以跳转了,这里是重点,重点.必须的要更改。<br>2. 设置搜索Docs Tool，把 Docs Tool改成gogetdoc或者guru试试，我的用guru就可以。</p>
<h2 id="自动补全失效"><a href="#自动补全失效" class="headerlink" title="自动补全失效"></a>自动补全失效</h2><p>解决：<br>在升级到 1.11后， go加入了go module这一特性， 支持相对路径的导入包，这样在$GOPATH之外的地方也可以进行项目开发。</p>
<ol>
<li>但是vscode中很多插件只能工作在 $GOPATH下， 其中最重要的代码智能提示也是如此代码提示主要由 github.com/mdemsky/gocode 这个模块负责， 为了支持go module， 要使用新的gocode模块，项目地址为 github.com/stamblerre/gocode， 为了更新插件</li>
</ol>
<p>将$GOPATH/bin 中的 gocode 可执行文件删掉</p>
<ol start="2">
<li><p>go get -u -v github.com/stamblerre/gocode 获取包， 这里是不能安装的，有冲突</p>
</li>
<li><p>去到 $GOPATH/src/golang.org/x 这个目录下， 删除tools这个包，它和新版的 gocode不兼容，不要试图 git pull获取最新版，这个是被墙了的</p>
</li>
<li><p>从 <a href="https://github.com/golang/tools">https://github.com/golang/tools</a> 下载最新的tools包，clone很慢就直接下载 zip 文件， 解压到刚才原来的位置。</p>
</li>
<li><p>编译安装 stamblerre/gocode， go build -o $GOPATH/bin/gocode-gomod github.com/stamblerre/gocode或者直接到$GOPATH/src/github.com/stamblerre/gocode目录下执行go build</p>
</li>
</ol>
<p>到此， Vscode智能提示就可以正常工作了</p>
]]></content>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】谈谈《博弈论诡计》</title>
    <url>/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>在一个咖啡屋偶然接触到这本书，当时旁边我翻遍了隔壁书架，一群要么是《骆驼祥子》，《呐喊》，《酒馆》这种上世纪的书，或是再给我整点余秋雨的风风雨雨，或者是再搞点三毛的恩恩爱爱，想找两本王朔的或者徐华的却翻不到，碰巧遇到了，博弈论。现在想起，可能是《博弈论》前两的囚徒困境吸引住了我吧。现在距看完这本书两个月了，许多片段还能历历在目。</strong></em></p>
<span id="more"></span>

<h2 id="对人的博弈"><a href="#对人的博弈" class="headerlink" title="对人的博弈"></a>对人的博弈</h2><p>我觉得如果是正经人对完这本书，应该对一点人情世故有所提升。我只能讲一下，我自己看完的对其浅薄的理解。每个人和其他人交往是时候都是在博弈，可能你自己没有注意到，但是和他人的博弈都是在井然有序的发生，默认的处理的方法就是经验论，参照别人处理的方式。这种方法总不能说是错的，但回头想想这可能不是最优解，每个人性格，遇到的矛盾总是不同而已的，一招鲜吃遍天，不太适用。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/1.jpeg" alt="图1"></p>
<p><code>举个栗子</code>：当你公司同事想去聚餐，想把你拉过去，但是你刚进公司，对公司同事不熟悉，这时候你就要考虑拒绝他还是答应他呢，我们画个表格。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/15.png" alt="图15"></p>
<p>表格上很清楚明了，如果你觉得自身的舒适度比同事好感度重要的话，合理的拒绝总是利大于弊的，如果是刚来公司，想在新公司发展的话，还是多多的参加聚餐与同事熟络。可能你觉得这个栗子比较简单，生活中的经验论完全就可以解决这个问题，但是事实上许多复杂的东西，就是需要这种逻辑，特别的当你的对手是一个相当成熟的职场上<code>高手</code>的时候，他的每一步都在深思熟虑，都在找一个最优解。历史上往往很离谱的事情，把我们代入过去一步一步分析，那个离谱结果可能就是就是最优解。</p>
<h2 id="对社会博弈理解"><a href="#对社会博弈理解" class="headerlink" title="对社会博弈理解"></a>对社会博弈理解</h2><p>社会上博弈从博弈论创始到现在，开始是冯·诺依曼证明了博弈论的基本原理，纳什有过完善，再～～～～～～～～发展，我就不记人名了，原谅我的差记性。大概是从提出的了博弈论，然后提出了博弈论的囚徒困境的局限性，再而破解了囚徒困境，提出了合作博弈理论，大概是这个历程。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/2.jpeg" alt="图2"></p>
<p><code>举个栗子</code>：知乎上有个问题说的很好，核武器的六层猜疑链核威慑里的六层猜疑链<br>什么叫核威慑？很多人理解的核威慑，就是你敢发射核弹搞死我，我就敢发射核弹搞死你。在那个曾经只有美苏拥有核武器的年代，核威慑确实是这样的。但如今不是了。冷战末期时，美国拥有核弹头31255枚，苏联那边也差不多，每年的维护保养费用都是一个天文数字。那个年代，美苏两国确实是奔着直接搞死对面的心态去的，而且要有能搞死对面很多遍的能力才放心。1991年，美苏两国达成协议，削减各自的核武器，直接把人类接近80%的核武器化为乌有。但即便如此，美苏两国依然各自拥有近7000枚核武器，依然可以把对方搞死很多遍。目前全人类总共有15000多枚核弹头，基本都在美国和俄罗斯那里。而中国的核武器一直数量很少，只有美苏两国的零头，大概几百枚的样子。如此之少的核武器，怎么和美俄抗衡？</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/3.jpeg" alt="图3"></p>
<p>以前的中国穷，造不起，甚至维护不起核武器，这可以理解。但今天的中国不穷了啊，为什么不造几万枚核武器撑场面？因为完全没有必几百枚核武器，已经够用了。够用的原因，不是因为几百枚核武器真的够用，而是因为美国和俄罗斯的核武器够用。美国和俄罗斯的核武器，就是中国的核武器。核武器+洲际导弹的组合，让核威慑产生了极其复杂的变化。如果美国决定拿出3000枚核武器，先发制人，在中国没有反应过来之前就对中国进行地毯式核轰炸，把中国从地球上彻底的抹去。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/4.jpeg" alt="图4"></p>
<p>那美国担心的是中国的核反制么？确实会担心，因为美国的反导系统不可能拦截中国发射的所有核武器，肯定有不少核弹头直接落在美国的大城市里。但这并不是美国最害怕的事情。美国最害怕的，是引发全球所有核国家的猜疑。首先，发动核攻击之前是要绝对保密的，绝对不可能对世界宣布的，更不可能挨个和盟友甚至敌国进行解释。这道理很好理解。假设你和对手都有枪，互相指着对手的头，谁都不敢开枪，这个时候如果对手告诉你，他准备开枪了，请问你会怎么做？</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/5.jpeg" alt="图5"></p>
<p>如果核攻击真的发动，那一定是毫无征兆的。<br>假如美国3000枚核弹头铺天盖地的向亚洲飞过来，在洲际导弹飞行的这十几分钟里，各核国家会想很多很多事情。</p>
<ul>
<li>第一层猜疑链：比如说俄罗斯，他首先会想一件事，这么多导弹到底是来炸谁的，是炸中国？还是炸俄罗斯？根据雷达测定，目前的飞行轨迹全部指向中国，看起来好像是炸中国的。但洲际导弹都是可以变轨的，这些弹头会不会在落地前分出一半，突然变轨来炸俄罗斯？等它变轨后，俄罗斯只有三分钟时间了，压根都没时间反应。如果等俄罗斯被炸了再反制，是不是太晚了？要不要提前发射核武器，先把美国给炸了，以防万一。这个问题，不仅俄罗斯会想，英国和法国也会想。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/6.jpeg" alt="图6"></p>
<ul>
<li>第二层猜疑链：除了害怕洲际导弹突然变轨之外，俄罗斯还会想一个问题。美国哪来的胆子突然炸中国的，他炸中国的目的是什么，他为什么敢炸中国。如果美国冒着本国被核弹攻击的风险，对中国发动核袭击，那为什么不顺便把俄罗斯一起给炸了，反正承担的风险是差不多的。所以，俄罗斯人会预估美国肯定会对俄罗斯发动核攻击。不管第一波核导弹是炸中国还是炸俄罗斯的，最后都一定会炸俄罗斯。既然如此，那俄罗斯索性就先动手吧。同样，这个问题，不仅俄罗斯会想，英国和法国也会想。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/7.jpeg" alt="图7"></p>
<ul>
<li>第三层猜疑链：更可怕的是，美国担心的绝不仅仅是俄罗斯的不信任。假设俄罗斯的领导人，有超强的定力，对美国有超强的信任，对人类有超强的慈悲之心，相信美国是只炸中国的，冒着俄罗斯人全部被屠灭的风险，最后没有下令发射核弹。俄罗斯还要担心一个问题，中国在对美国发动核反制的同时，会不会顺便给俄罗斯、英国、法国丢一波核弹。反正那个时候中国已经没了，名声这东西要来干嘛呢，大家一起死好了。这不是说中国一定会这么做，只要可能这么做就很可怕了。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/8.jpeg" alt="图8"></p>
<ul>
<li>第四层猜疑链：如果中国遭受美国核攻击后，可能会攻击全球核大国，那么英国法国应该如何自保？假如俄罗斯被炸了，哪怕只有几个主要大城市被炸了，国力都会严重削弱，从而彻底衰退，甚至可能会灭国。那么，俄罗斯会不会直接炸平全球，来确保俄罗斯的安全，或者拉全球给俄罗斯陪葬？如果英国和法国假定俄罗斯会这么做，那么为了英国和法国的国家利益最大化。从最理智的角度，英国和法国，应该立即发射所有的核弹，拉全球陪葬。偏偏一国领导人，一般来说都是相当理智的。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/12.jpeg" alt="图9"></p>
<ul>
<li>第五层猜疑链：当美国对中国发射核弹后，如果美国假定中国会核反制其他核大国，然后假定其他核大国为了自身利益最大化，都会直接把核弹头丢在美国头上，那美国会怎么应对这一情况？因为这个概率不仅有，而且还很高。作为美国，如果想要让本国利益最大化，在核攻击中国的同时，就应该同时核攻击俄罗斯、英国和法国等任何有能力对美国发动核攻击的国家。这才是美国最理性的选择。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/13.jpeg" alt="图10"></p>
<ul>
<li>第六层猜疑链：因为俄罗斯、英国和法国，都知道美国肯定会受困在第五层猜疑链，对本国发动核攻击的概率非常之大，自己无论怎么做都无法安抚美国。毕竟此时的美国已经疯了，如果不疯是无论如何都不敢发动核战争的。英法俄估计美国肯定会估计英法俄会估计美国会炸掉英法俄。所以英法俄无论如何都无法获得安全感。既然美国肯定会受困在猜疑链，肯定会对所有核国家发动打击，那么自己肯定就是个死。那，自己索性就拉全世界一起陪葬吧，说不定最后的情况还好一点。因此，在看到美国核弹头铺天盖地射向中国的一瞬间，俄罗斯、英国和法国，就会同时启动自己国家的核武库，向全世界所有国家发射核弹。你是真心实意的想炸中国？巧了，我怕你炸的不干净，或者导弹中途变向来炸我，我也帮你炸一遍中国吧，另外把你美国也全给炸了。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/11.jpeg" alt="图11"></p>
<p>这六层猜疑链，基本没有国家能熬过去。而且即便有个把国家的领导人熬过去了，也没用，需要所有核国家的领导人全部熬过去，拿命去相信彼此，才算破除猜疑链。上面的全是转自知乎，我觉得是个经典的博弈所以引用一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当我们不知道对方底牌时，保持沉默是一个不错的办法。</li>
<li>从长远来看，赌博是一个注定会输的游戏。</li>
<li>如果一开始就让人觉得你多么了不起，对你给予了种种厚望，可你随后的表现让人一次又一次的失望，结果你只会被人越来越看不起。这种反差效应值得人们借鉴。别人对你的期望值越高，越容易看出你的平庸，发现你的错误;相反，如果别人本来对你并不抱有厚望，你的成绩就回容易被人发现，甚至让人吃惊。</li>
<li>一个人的信息量是很有限的，要通过群体拓展思路，打开局面，才能在残酷的市场竞争中站稳脚跟。</li>
<li>“当你自估的成功概率达到%40~%70，你就该去这件事了。也许你会失败，但拖延或等待的代价往往更大。”</li>
<li>在幸福博弈时，不要拿自己的不幸和别人幸福的一面去比。决定你快乐或不快乐的，不是别人，是你自己。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/16.png" alt="图16"></p>
]]></content>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】systemctl和service启动服务</title>
    <url>/2021/04/25/systemctl%E5%92%8Cservice/</url>
    <content><![CDATA[<h1 id="Linux开启自启服务器"><a href="#Linux开启自启服务器" class="headerlink" title="Linux开启自启服务器"></a>Linux开启自启服务器</h1><p><em><strong>网上很多介绍systemctl和service的区别和使用，我觉得都没有说到点子上，本文介绍这两个自启动命令，并且加自己经常使用具体方法。</strong></em></p>
<span id="more"></span>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><ol>
<li><p>背景说明</p>
<blockquote>
<p>systemd，当系统启动之后systemd就会成功系统的第一个进程，而我们这个systemctl命令就是systemd命令中最重要的命令之一，用于管理系统。</p>
</blockquote>
<blockquote>
<p>systemctl命令在centos6及以下版本是不支持的，调用这个命令会报<code>命令未找到</code> or <code>command not found</code>错误,但是在7以上Linux为了提高系统的启动速度，尽可能的增加多个进程同时启动，所以就支持了systemd，也就是systemctl命令。</p>
</blockquote>
</li>
<li><p>调用方法</p>
<table>
<thead>
<tr>
<th align="left">systemctl 命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">systemctl stop</td>
<td align="left">停止</td>
</tr>
<tr>
<td align="left">systemctl start</td>
<td align="left">开始</td>
</tr>
<tr>
<td align="left">systemctl status</td>
<td align="left">查看状态</td>
</tr>
<tr>
<td align="left">systemctl mark</td>
<td align="left">注销</td>
</tr>
<tr>
<td align="left">systemctl suspend</td>
<td align="left">进入睡眠</td>
</tr>
<tr>
<td align="left">systemctl hibermate</td>
<td align="left">进入休眠</td>
</tr>
<tr>
<td align="left">systemctl get-default</td>
<td align="left">获得当前运行级别</td>
</tr>
</tbody></table>
</li>
<li><p>具体调用逻辑</p>
<blockquote>
<p>关键词daemon：后台服务进程，常驻。</p>
</blockquote>
<p> 文件保存路径主要是在以下三个路径，我自己写的service文件通常会用脚本，拷贝到下面三个路径中。</p>
<ul>
<li>/usr/lib/systemd/system</li>
<li>/run/systemd/system</li>
<li>/etc/systemd/system</li>
</ul>
<p> unit文件分很多种，我主要讲一下service文件和Target文件，这两个文件在写linux应用的时候用的比较多一点。</p>
<ol>
<li><p>service:文件扩展名为.service，用于定义系统服务，文件内容类似于desktop文件。</p>
<p> [unit]段常用的选项</p>
<ul>
<li>Description：描述信息，意义性描述</li>
<li>After：定义unit的启动顺序，晚于某服务启动</li>
<li>Requies：依赖其他的units，当依赖的服务没启动，是不能启动此服务的，强依赖</li>
<li>Waints：和上面一样，弱依赖</li>
<li>Conficts：定义units冲突关系（不太明白）</li>
</ul>
<p> [Service]段常用选项</p>
<ul>
<li><p>Type：用于定义影响ExecStart和相关参数功能unit进程启动类型</p>
<ol>
<li>simple:默认值，这个daemon主要由execstart后面所写的字符串来启动，启动后常驻内存。</li>
<li>forking:由 ExecStart 启动的程序通过 spawns 延伸出其他子程序来作为此 daemon 的主要服务。原生的父程序在启动结束后就会终止运行，ps：类似于管道启动</li>
<li>oneshot:与simple类似的启动方式类似，但是工作完就结束，不常驻内存</li>
<li>dbus:与simple类似的启动方式类似，但要设置DbusName=XX，daemon程序才会运行。</li>
<li>notify:暂时不了解</li>
<li>idle:与simple类似，要执行这个daemon 必须要所有的工作都顺利执行完毕后才会执行。这类的daemon 通常是开机到最后才执行即可的服务</li>
</ol>
</li>
<li><p>EnvironmentFile：环境配置文件</p>
</li>
<li><p>ExecStart：启动脚本或者命令进程</p>
</li>
<li><p>ExecStop：停止脚本或者命令进程</p>
</li>
</ul>
<p> [install]段常用选项</p>
<ul>
<li>Alias：暂时不了解</li>
<li>RequiredBy：被哪些units所依赖，强</li>
<li>WantedBy：如上，弱</li>
</ul>
</li>
<li><p>Target：文件扩展为.target，用于模拟实现“运行级别”。</p>
</li>
</ol>
<p> 举个实际性的例子，如果我完成了一个程序的编写或者脚本的编写，想让他开机启动并且常驻的话，我就可以自己写一个servcie文件，放入上文中三条路径中，类似下面这个文件。</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;test</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;home&#x2F;mecry&#x2F;DemonShell</span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

<p> ExecStart就是我在电脑中目标脚本，脚本中可以写一些监视开机启动的命令，输出到指定文件夹下，比如我监听笔记本闭合事件，开关机时间等，具体日志输出就在/home中的listen.txt文件下。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 | evtest &gt;&gt;/home/listen.txt</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>注意：脚本启动都是已root权限启动，方便调试。非root权限无法启动service服务</strong></p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><ol>
<li><p>背景说明</p>
<blockquote>
<p>service本质为进程，是linux最早控制服务的一种手段，并不是所有linux都有这个命令，主要是在redhat，fedora，mandriva，centos中 ，这个命令的可执行程序在/sbin下（一般进程都是在/usr/bin下）</p>
</blockquote>
</li>
<li><p>调用方法</p>
<blockquote>
<p>其实没什么调用方法，主要是看你service下的逻辑支持是什么实现，就可以怎么实现。<br> 比如<code>service dbus start</code>，其实调用dbus这个服务文件中start的函数实现。</p>
</blockquote>
</li>
<li><p>具体实现</p>
<p> 看个栗子，比如我本机的dbus服务,文件存放都存放在<code>/etc/init.d/</code>目录下。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          dbus</span></span><br><span class="line"><span class="comment"># Required-Start:    $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Required-Stop:     $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:</span></span><br><span class="line"><span class="comment"># Short-Description: D-Bus systemwide message bus</span></span><br><span class="line"><span class="comment"># Description:       D-Bus is a simple interprocess messaging system, used</span></span><br><span class="line"><span class="comment">#                    for sending messages between applications.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Debian init.d script for D-BUS</span></span><br><span class="line"><span class="comment"># Copyright © 2003 Colin Walters &lt;walters@debian.org&gt;</span></span><br><span class="line"><span class="comment"># Copyright © 2005 Sjoerd Simons &lt;sjoerd@debian.org&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">DAEMON=/usr/bin/dbus-daemon</span><br><span class="line">UUIDGEN=/usr/bin/dbus-uuidgen</span><br><span class="line">UUIDGEN_OPTS=--ensure</span><br><span class="line">NAME=dbus</span><br><span class="line">DAEMONUSER=messagebus</span><br><span class="line">PIDDIR=/var/run/dbus</span><br><span class="line">PIDFILE=<span class="variable">$PIDDIR</span>/pid</span><br><span class="line">DESC=<span class="string">&quot;system message bus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$DAEMON</span> || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source defaults file; edit that file to configure this script.</span></span><br><span class="line">PARAMS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -e /etc/default/dbus ]; <span class="keyword">then</span></span><br><span class="line">. /etc/default/dbus</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">create_machineid</span></span>() &#123;</span><br><span class="line"><span class="comment"># Create machine-id file</span></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="variable">$UUIDGEN</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$UUIDGEN</span> <span class="variable">$UUIDGEN_OPTS</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_it_up()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$PIDDIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir -p <span class="variable">$PIDDIR</span></span><br><span class="line">    chown <span class="variable">$DAEMONUSER</span> <span class="variable">$PIDDIR</span></span><br><span class="line">    chgrp <span class="variable">$DAEMONUSER</span> <span class="variable">$PIDDIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! mountpoint -q /proc/ ; <span class="keyword">then</span></span><br><span class="line">    log_failure_msg <span class="string">&quot;Can&#x27;t start <span class="variable">$DESC</span> - /proc is not mounted&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$PIDFILE</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$0</span> status &gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">    log_success_msg <span class="string">&quot;<span class="variable">$DESC</span> already started; not starting.&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    log_success_msg <span class="string">&quot;Removing stale PID file <span class="variable">$PIDFILE</span>.&quot;</span></span><br><span class="line">    rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">create_machineid</span><br><span class="line"></span><br><span class="line">log_daemon_msg <span class="string">&quot;Starting <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">start-stop-daemon --start --quiet --pidfile <span class="variable">$PIDFILE</span> \</span><br><span class="line">    --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> -- --system <span class="variable">$PARAMS</span></span><br><span class="line">log_end_msg $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shut_it_down()</span><br><span class="line">&#123;</span><br><span class="line">log_daemon_msg <span class="string">&quot;Stopping <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">start-stop-daemon --stop --retry 5 --quiet --oknodo --pidfile <span class="variable">$PIDFILE</span> \</span><br><span class="line">    --user <span class="variable">$DAEMONUSER</span></span><br><span class="line"><span class="comment"># We no longer include these arguments so that start-stop-daemon</span></span><br><span class="line"><span class="comment"># can do its job even given that we may have been upgraded.</span></span><br><span class="line"><span class="comment"># We rely on the pidfile being sanely managed</span></span><br><span class="line"><span class="comment"># --exec $DAEMON -- --system $PARAMS</span></span><br><span class="line">log_end_msg $?</span><br><span class="line">rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload_it()</span><br><span class="line">&#123;</span><br><span class="line">create_machineid</span><br><span class="line">log_action_begin_msg <span class="string">&quot;Reloading <span class="variable">$DESC</span> config&quot;</span></span><br><span class="line">dbus-send --print-reply --system --<span class="built_in">type</span>=method_call \</span><br><span class="line">            --dest=org.freedesktop.DBus \</span><br><span class="line">            / org.freedesktop.DBus.ReloadConfig &gt; /dev/null</span><br><span class="line"><span class="comment"># hopefully this is enough time for dbus to reload it&#x27;s config file.</span></span><br><span class="line">log_action_end_msg $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start_it_up</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">    shut_it_down</span><br><span class="line">;;</span><br><span class="line">reload|force-reload)</span><br><span class="line">    reload_it</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">    shut_it_down</span><br><span class="line">    start_it_up</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">    status_of_proc -p <span class="variable">$PIDFILE</span> <span class="variable">$DAEMON</span> <span class="variable">$NAME</span> &amp;&amp; <span class="built_in">exit</span> 0 || <span class="built_in">exit</span> $?</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: /etc/init.d/<span class="variable">$NAME</span> &#123;start|stop|reload|restart|force-reload|status&#125;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p> 说明：实际上dbus的service，就是一个.sh脚本，如果有C或者sh的基础就很好弄懂是什么意思，比如<code>service dbus start</code>，service进程就会从<code>/etc/init.d/</code>目录下找到dbus这个服务，这个sh脚本的<code>case</code>参数传入<code>start</code>，调用具体的实现逻辑。</p>
<p> 再举一个简单点的例子，和实际用法。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVERNAME= <span class="string">&quot;DemonShell&quot;</span></span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;start <span class="variable">$SERVERNAME</span>&quot;</span></span><br><span class="line">    /home/mecry/DemonShell</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;start <span class="variable">$SERVERNAME</span> ok!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span>  0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;stop <span class="variable">$SERVERNAME</span>&quot;</span></span><br><span class="line">    killall <span class="variable">$SERVERNAME</span></span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;stop <span class="variable">$SERVERNAME</span> ok!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>  <span class="string">&quot;<span class="variable">$1</span>&quot;</span>  <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">restart)</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;usage: <span class="variable">$0</span> start|stop|restart&quot;</span></span><br><span class="line">    <span class="built_in">exit</span>  0;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p> 和上面的systemctl一样，<code>/home/mecry/DemonShell</code>是我脚本存放位置，开机控制其启动，调用service也可以控制启动和关闭此脚本，非常方便。</p>
</li>
</ol>
<h2 id="systemctl和service优点缺点"><a href="#systemctl和service优点缺点" class="headerlink" title="systemctl和service优点缺点"></a>systemctl和service优点缺点</h2><pre><code>建议使用systemctl，比较规范方便
</code></pre>
]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【零零碎碎的技术】博客搭建</title>
    <url>/2021/04/20/blog%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="blog的搭建"><a href="#blog的搭建" class="headerlink" title="blog的搭建"></a>blog的搭建</h1><p><em><strong>此博客是github，用hexo，并用使用next主题进行配置和搭建。</strong></em></p>
<span id="more"></span>

<p><strong>吐槽一下，作为一名纯种的后端搭建blog，尽管网上有说明，但是还是觉得有些许吃力。特别是我换顶部图片，简直是我一步一步试出来的</strong></p>
<p>搭建步骤</p>
<ul>
<li>注册一个github，并且新建一个名字一样的github仓库</li>
<li>配置本地的hexo环境</li>
<li>下载next主题</li>
<li>直接在<code>_posts</code>下开始写博客</li>
<li>大功告成</li>
</ul>
<p>注意：</p>
<h4 id="问题1：背景图片更换"><a href="#问题1：背景图片更换" class="headerlink" title="问题1：背景图片更换"></a>问题1：背景图片更换</h4><p>解决：在<code>main.styl</code>加入<code>@import &quot;_custom/styles.styl&quot;</code>，背景图片放在<code>themes\next\source\images</code>文件夹中，本地创建<code>themes\next\source\css\ _custom\style.styl</code>文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123; </span><br><span class="line">background: url(<span class="regexp">/images/</span>图片名);</span><br><span class="line">background-repeat: no-repeat;<span class="comment">// 设定背景图片非重复填充</span></span><br><span class="line">background-attachment: fixed;<span class="comment">// 设置背景图片不随页面滚动</span></span><br><span class="line">background-position: <span class="number">50</span>% <span class="number">50</span>%;<span class="comment">// 设置背景图片位置</span></span><br><span class="line">background-size: cover<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题2：顶部图片更换"><a href="#问题2：顶部图片更换" class="headerlink" title="问题2：顶部图片更换"></a>问题2：顶部图片更换</h4><p>解决：在<code>headerband.styl</code>中插入下面那句话，背景图片放在站点的source/image下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.headband &#123;</span><br><span class="line">  <span class="comment">//background: $headband-bg;</span></span><br><span class="line">    background: url(<span class="string">&#x27;../../image/header-bg.jpg&#x27;</span>);</span><br><span class="line">  height: 180px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题3：文章置顶"><a href="#问题3：文章置顶" class="headerlink" title="问题3：文章置顶"></a>问题3：文章置顶</h4><p>解决：直接复制替换node_modules/hexo-generator-index/lib/generator.js的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    format: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>配置插件</p>
<p>$ npm uninstall hexo-generator-index –save</p>
<p>$ npm install hexo-generator-index-pin-top –save</p>
<p>然后在需要置顶的文章的Front-matter中加上top: true或者top数字top: 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">title: 置顶</span><br><span class="line">date: <span class="number">2019</span>-<span class="number">09</span>-<span class="number">09</span> <span class="number">09</span>:<span class="number">09</span>:<span class="number">09</span></span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">top: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>按照数字大小依次往下置顶排序</p>
]]></content>
      <tags>
        <tag>零零碎碎的技术</tag>
      </tags>
  </entry>
</search>
