<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Linux技术分享】呼叫器窗口问题分析</title>
    <url>/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>呼叫器在nfs系统中启动后，在菜单栏无图标显示，但窗口正常显示，用户在最小化窗口时无法找到窗口再启动</p>
<p>正常现象如下图：</p>
<p><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/1.png"></p>
<p>异常现象如下图：</p>
<p><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/2.png"></p>
<p><em><strong>经验证问题复现环境为：</strong></em></p>
<p><em>软件环境</em>：amd架构，nfs-5.0-G212p版本</p>
<p><em>硬件环境</em>：需要amd架构处理器</p>
<p><em>wine版本</em>：上游wine-8.6</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol>
<li>观察现象，根据曾经的mfc，x11编程经验来看，该类问题的出现有两种可能的原因：<ul>
<li>猜测1：在linux下怀疑启动窗口存在隐藏图标属性</li>
<li>猜测2：是在创建菜单栏时，加载rc的api在wine下不支持或者存在bug</li>
<li>猜测3：在nfs系统下，任务栏加载这个进程时图标显示失败</li>
</ul>
</li>
</ol>
<h2 id="分析验证"><a href="#分析验证" class="headerlink" title="分析验证"></a>分析验证</h2><h3 id="猜测1："><a href="#猜测1：" class="headerlink" title="猜测1："></a>猜测1：</h3><ol>
<li>介绍两个观察x窗口的工具,xprop与xwininfo<pre><code> - xwininfo：列出窗口的基本几何信息和状态，简单用法是在终端里面执行命令 `xwininfo` 之后， 此时系统鼠标光标被 `xwininfo` 捕获，光标变成十字星形状，移动鼠标点击要查看的窗口的任意区域，执行`xwininfo`的终端输出了该窗口的这些 X11 属性.
 - 列出窗口的全部X11属性，简单用法是在终端里面执行命令 `xprop` 之后， 此时系统鼠标光标被 `xprop` 捕获，光标变成十字星形状，移动鼠标点击要查看的窗口的任意区域，执行`xprop`的终端输出了该窗口的所有 X11 属性.
</code></pre>
</li>
<li>通过xwininfo获取窗口id，再通过xprop -id <window_id> _NET_WM_STATE | grep “_NET_WM_STATE_SKIP_TASKBAR”，判断呼叫器窗口未设置隐藏菜单栏窗口属性</window_id></li>
</ol>
<h3 id="猜测2："><a href="#猜测2：" class="headerlink" title="猜测2："></a>猜测2：</h3><ol>
<li>开启api monitor监控，按照问题在nfs上复现的步骤在windows上操作呼叫器，关注<code>loadicon</code>，<code>loadimge</code>，<code>createicon</code>,等关于hfont创建加载的函数，发现有两个创建有<code>icon</code>资源加载<br><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/3.png"><br><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/4.png"></li>
<li>发现存在两个窗口都有<code>icon</code>资源加载，通过<code>spy++</code>确定目标创建句柄，通过<code>api monitor</code>或者<code>od</code>观察句柄创建后的函数，发现窗口调用<code>ole.dll</code>的<code>OleLoadPictureExt</code>函数加载资源并在<code>createwindow</code>下进行赋值。<br><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/5.png"></li>
<li>本地实现简单demo，加载图片资源然后创建窗口进行赋值，如下（/呼叫器/code/demo.c）： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载图像并设置为窗口图标</span></span><br><span class="line"><span class="function">HICON <span class="title">LoadAndSetWindowIcon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CoInitialize</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 假设pStream已经被初始化并包含了图片数据</span></span><br><span class="line">    IStream *pStream = <span class="built_in">ReadImageToLPSTREAM</span>();</span><br><span class="line">    <span class="comment">// 图片的宽度和高度（设为0表示使用默认的图片尺寸）</span></span><br><span class="line">    LONG width = <span class="number">0</span>;</span><br><span class="line">    LONG height = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否保持图片的比例</span></span><br><span class="line">    BOOL keepAspectRatio = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    IPicture *pPicture = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = <span class="built_in">OleLoadPictureEx</span>(pStream, <span class="number">0</span>, FALSE, IID_IMyInterface, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span> **)&amp;pPicture);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取图标句柄</span></span><br><span class="line">        HICON hIcon = <span class="literal">NULL</span>;</span><br><span class="line">        pPicture-&gt;<span class="built_in">get_Handle</span>((OLE_HANDLE*)&amp;hIcon);</span><br><span class="line">        <span class="keyword">return</span> hIcon;</span><br><span class="line">        <span class="comment">// 设置窗口类的图标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>发现图标显示正常显示，日志也与呼叫器窗口创建保持一致</li>
</ol>
<h3 id="猜测3："><a href="#猜测3：" class="headerlink" title="猜测3："></a>猜测3：</h3><ol>
<li>菜单栏图标显示简介：菜单栏在对系统来说也是一个进程，每个进程在菜单栏进行显示需要进程提供窗口类型，窗口消息，窗口图标等，同样菜单栏移除显示也会遵循某种规则</li>
<li>通过猜测1中的<code>xwininfo</code>的<code>xwininfo -tree -root</code>命令获取到系统菜单栏的进程是<code>cods-desktop</code><br><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/6.png"></li>
<li><code>cdos</code>是Cromemco 推出的一种类似 CP/M 的操作系统，猜测方德是桌面系统是沿用cdos系统源码，但菜单栏属于深度diy的代码，上游开源代码可能与nfs相差比较大，所以暂未考虑查看上游代码进行排查问题</li>
<li><code>cdos-desktop --help</code>发现增加参数可以输出日志，编写脚本将日志输出至终端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">export GTK_DEBUG=all</span><br><span class="line">killall cdos-desktop</span><br><span class="line">cdos-desktop -b</span><br></pre></td></tr></table></figure></li>
<li>运行程序捕捉日志，发现呼叫器启动后菜单栏将其进行移除<br><img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/7.png"></li>
<li>通过猜测2中的源码观察，大致可以理清呼叫器窗口创建流程，创建父窗口-&gt;创建子窗口-&gt;隐藏父窗口，编写demo进行验证，demo较简单（/呼叫器/code/win.c） <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hwndParent = <span class="built_in">CreateWindowEx</span>(<span class="number">0</span>, parentClassName, <span class="string">&quot;Parent&quot;</span>, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, <span class="number">800</span>, <span class="number">800</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwndParent, nCmdShow);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(hwndParent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子窗口</span></span><br><span class="line">hwndChild = <span class="built_in">CreateWindowEx</span>(<span class="number">0</span>, childClassName, <span class="string">&quot;child&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">150</span>, hwndParent, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwndParent, SW_HIDE);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwndChild, nCmdShow);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(hwndChild);</span><br></pre></td></tr></table></figure></li>
<li>在nfs系统上进行验证，发现同样菜单栏下无法显示图标</li>
</ol>
<h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><pre><code>通过上述分析与验证代码，可以初步猜测在nfs系统上使用wine创建子窗口与父窗口时隐藏父窗口，会使cdos-desktop程序将进程任务栏图标进行移除。在nfs验证后，将同样wine代码与测试代码在deepin进行验证，未发现异常问题，图标正常显示。
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>方案1： 与系统组沟通修改cdos-desktop的bug（时间较长，暂不考虑）</li>
<li>方案2：修改父窗口属性，在父窗口被移除时的窗口属性中，不增加<code>_NET_WM_STATE_SKIP_TASKBAR</code>代码如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-1059</span>,<span class="number">6</span> +<span class="number">1059</span>,<span class="number">9</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">update_net_wm_states</span><span class="params">( struct x11drv_win_data *data )</span></span></span><br><span class="line"><span class="function">             <span class="title">if</span> <span class="params">(!(new_state &amp; (<span class="number">1</span> &lt;&lt; i)))</span> <span class="keyword">continue</span></span>;</span><br><span class="line">             TRACE( <span class="string">&quot;setting wm state %u for unmapped window %p/%lx\n&quot;</span>,</span><br><span class="line">                    i, data-&gt;hwnd, data-&gt;whole_window );</span><br><span class="line">+	    <span class="keyword">if</span>(i == NET_WM_STATE_SKIP_TASKBAR) &#123;</span><br><span class="line">+		    <span class="keyword">continue</span>;</span><br><span class="line">+	    &#125;</span><br><span class="line">             atoms[count++] = X11DRV_Atoms[net_wm_state_atoms[i] - FIRST_XATOM];</span><br><span class="line">             <span class="keyword">if</span> (net_wm_state_atoms[i] == XATOM__NET_WM_STATE_MAXIMIZED_VERT)</span><br><span class="line">                 atoms[count++] = x11drv_atom(_NET_WM_STATE_MAXIMIZED_HORZ);</span><br></pre></td></tr></table></figure>
修改后效果如下：<br>  <img src="/2023/09/06/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/png/8.png"></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个问题产生后，可以先看看问题现象，找到产生问题的操作规律，从操作上可以大胆推测问题出现的可能出现的几种原因，然后再通过测试用例或者其它手段一一排除。同样的功能，代码实现的方法有多种，写测试用例前，可以网上查看下实现一个功能比较常见的几种手法，这样可以缩小apimonitor监控的过滤范围。结合apimonitor调用的接口，再写测试用例就可以比较准确的复现问题。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】go实现简单dbus</title>
    <url>/2023/08/07/go%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0dbus/</url>
    <content><![CDATA[<h1 id="go实现简单dbus"><a href="#go实现简单dbus" class="headerlink" title="go实现简单dbus"></a>go实现简单dbus</h1><p><em><strong>实现一个控制访问权限的dbus demo，<a href="https://github.com/lk-me/nfs-hotpot-regist">代码地址</a>。</strong></em></p>
<span id="more"></span>

<h1 id="nfs-hotpot-regist"><a href="#nfs-hotpot-regist" class="headerlink" title="nfs-hotpot-regist"></a>nfs-hotpot-regist</h1><pre><code>`nfs-hotpot-regist`目前为dbus框架，用于后期存储nfs系统上的hotpot信息，使用go开发。
</code></pre>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>单例</li>
<li>调用者校验，包括权限与调用者名称</li>
<li>提供存储与读取接口</li>
<li>将信息存储值属性中，实现秒读取</li>
<li>提供日志模块，将日志存储至系统日志中</li>
</ul>
<h3 id="debian-ubuntu"><a href="#debian-ubuntu" class="headerlink" title="/debian/ubuntu"></a>/debian/ubuntu</h3><ul>
<li>apt install libdbus-1-dev</li>
<li>在主目录使用makefile编译</li>
<li>make</li>
<li>sudo make install</li>
<li>sudo ./nfs-hotpot-regist</li>
</ul>
<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><ul>
<li><code>/cmd</code>主程序目录</li>
<li><code>/config</code>存放配置文件</li>
<li><code>/test</code>测试程序，目前用c开发测试dbus接口</li>
<li><code>/pkg/logger</code>日志模块</li>
<li><code>/pkg/hotpot</code>主程序逻辑模块</li>
<li><code>/pkg/module</code>主程序调用模块</li>
</ul>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ul>
<li>接口功能待实现</li>
<li>日志模块后期修改为输出至文件</li>
<li>单元测试</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2023/06/13/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>用户在使用摄像头捕捉软件时，windows下点击属性设置button时，可以弹出关于设置当前使用摄像头属性窗口，在wine下点击无响应，在windows显示弹窗如下：<br><img src="/2023/06/13/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/1.png" alt="图1"><br>经测试在不同摄像头插入时，弹出窗口界面展示不同。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><ol>
<li>使用spy++分析窗口组成，发现组成窗口都是由windows api绘制<br><img src="/2023/06/13/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/2.png" alt="图2"></li>
<li>通过google搜图，发现此窗口为通用窗口，在obs等摄像头捕捉软件都存在。</li>
</ol>
<p>根据以上确定此窗口非当前软件绘制，为windows的提供的摄像头设置窗口。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ol>
<li><p>根据<code>问题定位</code>，发现设置属性窗口为windows提供。通过google可以了解windows视频录制框架大致为Windows Media Foundation（WMF）与DirectShow，在wine中通过模块开启发现应用通过DirectShow框架捕捉视频</p>
<ul>
<li>DirectShow：DirectShow 是一种基于 COM 的框架，可用于创建和管理音频和视频流。它提供了一组可编程的组件，称为过滤器，用于捕获、压缩、转换和渲染音频和视频流。应用程序可以使用 DirectShow 来捕获和编码视频，然后将其保存为文件或流式传输到网络。</li>
</ul>
</li>
<li><p>查询msdn，了解DirectShow属性页弹出基本原理，编写demo（demo代码见文件夹demo），发现弹出界面与应用弹出设置界面一致</p>
<ul>
<li><p>属性页原理：DirectShow滤镜是一个COM对象，因此它实现了IUnknown接口，包括QueryInterface方法。在DirectShow中，每个滤镜都可以实现不同的接口来提供不同的功能，例如播放音频和视频、录制视频、捕获窗口等等。为了获取滤镜支持的特定接口，您可以使用滤镜对象的QueryInterface方法，并提供要获取的接口的IID（接口标识符）。ISpecifyPropertyPages接口是DirectShow中用于获取滤镜属性页的接口之一。当您调用pFilter-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void**)&amp;pSpecPropPages)函数时，DirectShow会检查该滤镜是否支持ISpecifyPropertyPages接口。如果滤镜支持该接口，则DirectShow会返回S_OK，并将ISpecifyPropertyPages接口的指针存储在pSpecPropPages变量中。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hr = pBaseFilter-&gt;<span class="built_in">QueryInterface</span>(IID_ISpecifyPropertyPages, (<span class="keyword">void</span>**)&amp;pSpecPropPages);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">    hr = pSpecPropPages-&gt;<span class="built_in">GetPages</span>(pCaGUID);</span><br><span class="line">    pSpecPropPages-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li>将windows的demo移动至wine中进行运行，发现设置弹出未弹出，通过日志观察，发现运行至vfw_capture_query_interface函数中获取com接口时，返回E_NOINTERFACE<br><img src="/2023/06/13/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/3.png" alt="图3"><br><img src="/2023/06/13/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/4.png" alt="图4"></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>wine未实现IID_ISpecifyPropertyPages接口，导致点击设置属性button无响应。窗口显示流程可以大致为 <code>用户点击属性设置窗口-&gt;windows获取驱动可设置参数-&gt;根据参数组成设置界面-&gt;显示至用户</code>。目前wine在<code>windows获取驱动可设置参数</code>步骤中未实现。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>方案1：调研windows获取驱动可设置参数接口如何实现，在wine中进行代码补充<br>优点：彻底解决窗口无法弹出问题，可对wine的DirectShow有较大的技术积累<br>缺点：耗时较长，需要调研问题较多，要把windows关于DirectShow驱动设置流程与linux摄像头驱动设置流程进行分析，再结合wine代码对其进行补充。</p>
<p>方案2：与开发厂商进行沟通，在程序启动时，提供默认设置，设置属性窗口可不弹出也可使用软件。<br>优点：可快速有效解决厂商问题。<br>缺点：在wine中根据图4代码，只能设置基础项，可能无法满足用户设置并且此方案为临时方案不通用。。</p>
]]></content>
  </entry>
  <entry>
    <title>【Linux技术分享】无法打开视频驱动设置弹窗根因分析</title>
    <url>/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>用户在使用摄像头捕捉软件时，windows下点击属性设置button时，可以弹出关于设置当前使用摄像头属性窗口，在wine下点击无响应，在windows显示弹窗如下：<br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/1.png" alt="图1"><br>经测试在不同摄像头插入时，弹出窗口界面展示不同。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><ol>
<li>使用spy++分析窗口组成，发现组成窗口都是由windows api绘制<br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/2.png" alt="图2"></li>
<li>通过google搜图，发现此窗口为通用窗口，在obs等摄像头捕捉软件都存在。</li>
</ol>
<p>根据以上确定此窗口非当前软件绘制，为windows的提供的摄像头设置窗口。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ol>
<li><p>根据<code>问题定位</code>，发现设置属性窗口为windows提供。通过google可以了解windows视频录制框架大致为Windows Media Foundation（WMF）与DirectShow，在wine中通过模块开启发现应用通过DirectShow框架捕捉视频</p>
<ul>
<li>DirectShow：DirectShow 是一种基于 COM 的框架，可用于创建和管理音频和视频流。它提供了一组可编程的组件，称为过滤器，用于捕获、压缩、转换和渲染音频和视频流。应用程序可以使用 DirectShow 来捕获和编码视频，然后将其保存为文件或流式传输到网络。</li>
</ul>
</li>
<li><p>查询msdn，了解DirectShow属性页弹出基本原理，编写demo（demo代码见文件夹demo），发现弹出界面与应用弹出设置界面一致</p>
<ul>
<li><p>属性页原理：DirectShow滤镜是一个COM对象，因此它实现了IUnknown接口，包括QueryInterface方法。在DirectShow中，每个滤镜都可以实现不同的接口来提供不同的功能，例如播放音频和视频、录制视频、捕获窗口等等。为了获取滤镜支持的特定接口，您可以使用滤镜对象的QueryInterface方法，并提供要获取的接口的IID（接口标识符）。ISpecifyPropertyPages接口是DirectShow中用于获取滤镜属性页的接口之一。当您调用pFilter-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void**)&amp;pSpecPropPages)函数时，DirectShow会检查该滤镜是否支持ISpecifyPropertyPages接口。如果滤镜支持该接口，则DirectShow会返回S_OK，并将ISpecifyPropertyPages接口的指针存储在pSpecPropPages变量中。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hr = pBaseFilter-&gt;<span class="built_in">QueryInterface</span>(IID_ISpecifyPropertyPages, (<span class="keyword">void</span>**)&amp;pSpecPropPages);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">    hr = pSpecPropPages-&gt;<span class="built_in">GetPages</span>(pCaGUID);</span><br><span class="line">    pSpecPropPages-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li>将windows的demo移动至wine中进行运行，发现设置弹出未弹出，通过日志观察，发现运行至vfw_capture_query_interface函数中获取com接口时，返回E_NOINTERFACE<br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/3.png" alt="图3"><br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/4.png" alt="图4"></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>wine未实现IID_ISpecifyPropertyPages接口，导致点击设置属性button无响应。窗口显示流程可以大致为 <code>用户点击属性设置窗口-&gt;windows获取驱动可设置参数-&gt;根据参数组成设置界面-&gt;显示至用户</code>。目前wine在<code>windows获取驱动可设置参数</code>步骤中未实现。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>方案1：调研windows获取驱动可设置参数接口如何实现，在wine中进行代码补充<br>优点：彻底解决窗口无法弹出问题，可对wine的DirectShow有较大的技术积累<br>缺点：耗时较长，需要调研问题较多，要把windows关于DirectShow驱动设置流程与linux摄像头驱动设置流程进行分析，再结合wine代码对其进行补充。</p>
<p>方案2：与开发厂商进行沟通，在程序启动时，提供默认设置，设置属性窗口可不弹出也可使用软件。<br>优点：可快速有效解决厂商问题。<br>缺点：在wine中根据图4代码，只能设置基础项，可能无法满足用户设置并且此方案为临时方案不通用。。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】deepin实现boot分区加密</title>
    <url>/2023/04/19/deepin%E5%AE%9E%E7%8E%B0boot%E5%88%86%E5%8C%BA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="deepin实现boot分区加密"><a href="#deepin实现boot分区加密" class="headerlink" title="deepin实现boot分区加密"></a>deepin实现boot分区加密</h1><p><em><strong>当前linux下的磁盘加密，为了保证系统的正常启动，一般不会将引导分区进行加密。luck2在grub2.06版本以后支持了boot分区加密，但是仍然无法支持mbr分区格式的引导加密，本文旨在解决此问题</strong></em></p>
<span id="more"></span>
<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>在原子更新开发时，发现引导项需要保存至/boot分区中，但是/boot分区的存储空间固定的，再多个版本迭代进行更新后会出现分区空间不足问题，此时需考虑将引导向的备份存储至其他分区。如果用户选择了全盘加密，在用户的grub内核选择阶段，必须将加密磁盘解密，否则找到当前备份的内核文件，此时问题则变为如何在grub阶段或者在grub阶段前将磁盘进行解密，等效于加密/boot分区后如何在grub阶段前将/boot分区进行解密。</p>
<h2 id="boot分区解密"><a href="#boot分区解密" class="headerlink" title="boot分区解密"></a>boot分区解密</h2><h3 id="mbr启动流程"><a href="#mbr启动流程" class="headerlink" title="mbr启动流程"></a>mbr启动流程</h3><ol>
<li><p>mbr主要组成为core.img的结构，首先是diskboot.img，接下来是解压缩程序lzma_decompress.img，再往下是kernel.img，最后是各个模块module对应的映像，细节查看，<a href="http://www.pixelbeat.org/docs/disk/%E3%80%82">http://www.pixelbeat.org/docs/disk/。</a><br><img src="/2023/04/19/deepin%E5%AE%9E%E7%8E%B0boot%E5%88%86%E5%8C%BA%E5%8A%A0%E5%AF%86/1.png" alt="图1"></p>
</li>
<li><p>首先读取第一扇区的boot.img，该文件处的某处一定保存了整个core.img的起始扇区，然后从该起始扇区处首先读取一个扇区，即diskboot.img，该映像的结尾处保存了后续映像的长度，根据该长度读取这些数据，数据的头部即lzma_decompress.img映像又保存了加压缩的参数，例如压缩文件的大小，以及解压缩后文件的大小，根据这些参数对后续数据进行解压缩，得到kernel.img以及各个module模块的映像起始地址，最后进入kernel.img的入口函数继续执行，具体模块查看<a href="https://www.gnu.org/software/grub/manual/grub/html_node/Images.html%E3%80%82">https://www.gnu.org/software/grub/manual/grub/html_node/Images.html。</a></p>
</li>
</ol>
<h3 id="uefi启动流程"><a href="#uefi启动流程" class="headerlink" title="uefi启动流程"></a><del>uefi启动流程</del></h3><h3 id="grub2-06-luks2-mbr"><a href="#grub2-06-luks2-mbr" class="headerlink" title="grub2.06+luks2+mbr"></a>grub2.06+luks2+mbr</h3><p>根据mbr启动流程，我们可知，将我们的解密代码存放至core文件中，即可在grub加载前对磁盘进行解密。</p>
<ol>
<li>创建脚本grub-pre.cfg内容如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cryptomount -a</span><br><span class="line">set root&#x3D;crypto0</span><br><span class="line">set prefix&#x3D;($root)&#x2F;grub</span><br><span class="line">insmod normal</span><br><span class="line">normal</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>生成img文件， grub-mkimage -p /boot/grub -O i386-pc -c grub-pre.cfg -o /boot/grub/i386-pc/core2.img luks2 part_gpt cryptodisk gcry_rijndael pbkdf2 gcry_sha256 ext2 part_msdos biosdisk</p>
</li>
<li><p>将img文件写入磁盘头，grub-bios-setup -b i386-pc/boot.img -c i386-pc/core2.img /dev/sda</p>
</li>
<li><p>效果如下<br><img src="/2023/04/19/deepin%E5%AE%9E%E7%8E%B0boot%E5%88%86%E5%8C%BA%E5%8A%A0%E5%AF%86/1.png" alt="图1"></p>
</li>
</ol>
<h3 id="grub2-06-luks1"><a href="#grub2-06-luks1" class="headerlink" title="grub2.06+luks1"></a>grub2.06+luks1</h3><p>deepin的20.8需要将luks2降至luks1,但在efi与mbr下都能实现引导加密，具体的操作可以看debian的<a href="https://cryptsetup-team.pages.debian.net/cryptsetup/encrypted-boot.html">官方文档</a></p>
<h3 id="grub2-06-luks2-efi"><a href="#grub2-06-luks2-efi" class="headerlink" title="grub2.06+luks2+efi"></a>grub2.06+luks2+efi</h3><p>在grub2.06版本上对引导加密方案是部分支持，具体细节跟加密步骤查看<a href="https://wiki.archlinux.org/title/GRUB#LUKS2">arch的wiki</a></p>
]]></content>
      <categories>
        <category>原子更新</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】原子更新调研分析（二）deepin原子更新调研开发</title>
    <url>/2023/04/18/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89deepin%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h1 id="原子更新调研分析（一）deepin原子更新调研开发"><a href="#原子更新调研分析（一）deepin原子更新调研开发" class="headerlink" title="原子更新调研分析（一）deepin原子更新调研开发"></a>原子更新调研分析（一）deepin原子更新调研开发</h1><p><em><strong>deepin的原子开发告一段落，项目已经交给社区维护，仓库在：<a href="https://github.com/linuxdeepin/deepin-upgrade-manager%E3%80%82%E9%A2%84%E8%AE%A1%E5%86%99%E5%87%A0%E7%AF%87%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95%E4%B8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E7%BB%86%E8%8A%82%E4%B8%8E%E5%88%9D%E8%A1%B7%EF%BC%8C%E7%AE%97%E6%98%AF%E5%AF%B9%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%AD%E3%80%82">https://github.com/linuxdeepin/deepin-upgrade-manager。预计写几篇文档记录下开发的细节与初衷，算是对这个项目的总结叭。</a></strong></em></p>
<span id="more"></span>
<h2 id="原子更新是什么"><a href="#原子更新是什么" class="headerlink" title="原子更新是什么"></a>原子更新是什么</h2><pre><code>原子更新是对deepin系统级别的备份方案，为什么叫原子更新呢？原子说明本次操作是不可中断的，连一起意思就是本次系统更新是可靠的，可逆的，不可中断的意思，旨在解决deepin的系统更新不稳定的问题，若存在系统更新崩溃可随时回到之前备份的任意节点，保证系统数据。
</code></pre>
<h2 id="老版本存在问题"><a href="#老版本存在问题" class="headerlink" title="老版本存在问题"></a>老版本存在问题</h2><ol>
<li>deepin在v20以及v20之前，在系统备份的时候使用的都是ab分区。ab分区的劣势主要是只能支持全盘分区的，像自定义分区的就无法支持，并且只能备份一个版本，有时候a,b版本的备份内容都存在问题时就很棘手，无法找到之前版本了。</li>
<li>ab备份的时候，全盘安装的时候会多一个分区来存储系统文件，当时的主分区无法调整，就是因为ab分区需要空间太大了这个原因，如果主分区是要30g空间，那个备份分区也需要30g,会对磁盘空间有较大浪费。</li>
<li>备份时间较长，在ab分区的时候，需要将主分区内容全部拷贝到另一个分区，如果是机械磁盘，耗费的时候就是非常长的了。</li>
</ol>
<h2 id="原子更新优势"><a href="#原子更新优势" class="headerlink" title="原子更新优势"></a>原子更新优势</h2><ol>
<li>可以备份任意版本，多个数量系统版本</li>
<li>由于是增量备份，所以备份速度较快，回滚也较快，占据空间较小。</li>
</ol>
<h2 id="原子更新劣势"><a href="#原子更新劣势" class="headerlink" title="原子更新劣势"></a>原子更新劣势</h2><ol>
<li>与debian的管理包应用的软件耦合较低，无法做到像rpm-ostree对每一个应用进行备份管理。</li>
<li>由于第一个原因，所以备份的时候需要对系统进行一个文件校验，查询每次安装应用后增加的应用，有时间消耗。</li>
</ol>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ol>
<li>希望与系统耦合增加，能明确知道每次应用更新内容</li>
<li>增加只读根分区功能，通过原子更新来组成os进行系统更新</li>
<li>系统更新应该是一个阻塞功能，用户不能进行对系统进行操作，类比windows/手机的系统更新。</li>
<li>改造ostree,当前ostree是单线程，原子更新备份与回滚是为阻塞操作，可以将其改造为多线程操作。</li>
</ol>
<h2 id="实现原理简介"><a href="#实现原理简介" class="headerlink" title="实现原理简介"></a>实现原理简介</h2><p>原子更新的具体实现在github上的<a href="https://github.com/linuxdeepin/deepin-upgrade-manager/blob/master/docs/deepin-atomic-upgrade_outline_detailed_design.tex">概要设计</a>，这里简单讲一下，并把一些遇到的困难点记录一下。原子更新由于是系统级别应用，需要尽可能减少依赖，所以使用<code>go</code>开发，主要分层如下图：<img src="/2023/04/18/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89deepin%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94/1.png" alt="图1"></p>
<ol>
<li>其中deepin-boot-kit是管理grub显示更新，原子更新的grub引导项展示由此模块支持，后期可以讲一下这个模块以及grub原理。</li>
<li>原子更新支持命令行与dbus两种方案的调用，dbus则为通用接口，命令行则为了在initramfs下使用。</li>
<li>用户可以使用 commit,init,rollback,version的直接命令调用原子更新</li>
<li>原子更新内部则封装ostree的命令，实现底层接口，后期ostree也可以换其他的文件级别的备份方案。</li>
</ol>
<h2 id="开发困难点"><a href="#开发困难点" class="headerlink" title="开发困难点"></a>开发困难点</h2><ol>
<li>自动选择最大分区</li>
<li>断电回滚，重启后继续回滚</li>
<li>引导分区的加密</li>
<li>提交时快速找到系统增量文件，提交至ostree仓库</li>
<li>回滚时，快速建立rootfs对系统进行替换</li>
</ol>
]]></content>
      <categories>
        <category>原子更新</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】chatgpt使用</title>
    <url>/2023/02/23/chatgpt%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="chatgpt学习与工作上应用"><a href="#chatgpt学习与工作上应用" class="headerlink" title="chatgpt学习与工作上应用"></a>chatgpt学习与工作上应用</h1><p><em><strong>vscode下使用chatgpt加快工作效率。</strong></em></p>
<span id="more"></span>

<p>在一个领域刚入门的时候，可能一头雾水没办法精准的确定需求告诉google自己想要什么，只能够模糊搜索再慢慢确认自己的需求，但是我们现在有了chatgpt,可以将大致需求告诉他，你会给你一个<code>看起来</code>很精准的结果，注意是看起来，笔者自验在chatgpt与微软的msdn搜索的api进行对比发现还是有些许出入。我们可以把chatgpt比喻成图书管理员，具体知识他可能不大清楚，但是他可以帮助你剩下很长时间确定在哪个位置。</p>
<p>在vscode上使用chatgpt,需要对vscode进行代理配置，在设置中搜索<code>proxy</code>进行代理配置（如果使用sock5需要把完整的代理链接都贴上去），第一次登陆chatgpt会要求输入<code>key</code>进行配置，<code>key</code>的获取需要登陆<code>openai</code>。配置完成后其效果如下：<img src="/2023/02/23/chatgpt%E4%BD%BF%E7%94%A8/%E5%9B%BE1.jpg" alt="图1"></p>
<p>推荐一个开源项目，把微信机器人与chatgpt绑定一起了，实现一个ai好友。<a href="https://github.com/SnapdragonLee/ChatGPT-weBot%E3%80%82">https://github.com/SnapdragonLee/ChatGPT-weBot。</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】读《人生的智慧》</title>
    <url>/2022/10/16/%E8%AF%BB%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>《人生的智慧》 一本引人入胜而又充满智慧的哲学书。</strong></em></p>
<span id="more"></span>

<p>什么是人生的智慧呢？在我看来是对人生的态度，在对一些客观发生的悲剧时，倘若长时间的陷入痛苦与自责，往往会让自己生陷入悲剧之中，在此时对平常的细小的问题时总会容易易怒，充满负面情绪，但若转换自身角度，在悲伤过后总结问题原因从而警戒自己，当我们遇到相同或者类似问题时，就会回想当时的痛苦与自责从而避免悲剧发生。</p>
<p>叔本华这本《人生的智慧》阐述的如何尽量快乐的度过这一生，算得上是哲学的幸福论，对于幸福每个人的定义不同，对于我而言我每周会去吃顿烧烤/火锅/日料去放松下自身紧绷的身体，这就是对我的幸福，但若对于已经饿了数天的乞丐来说，此时能吃上白面馒头难道他的幸福感不会比我高的多么？</p>
<p>更好是好的敌人，痛苦是产生快乐的根源，他们不是反义词而是近义词，对于个体来讲存在痛苦才会产生快乐，身边简单的幸福感总是难以被重视或者看见，就像一位双眼视力正常的人很难想象拥有一双正常的双眼对失明的人多快乐。只有经历了巨大的灾难才能感受到自身已存在的幸福。如何评断当前是否幸福呢？当我们每天都只为了细小的事情烦恼时，那应该就是最幸福的时候，所以要珍惜这段时光。</p>
<p>强烈推荐买一本进行阅读，是一本很有价值的指导生活的哲学书籍~</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>理性的人寻求的不是快乐，而只是没有痛苦。</li>
<li>快乐只不过是一场梦，但痛苦确实真实存在的。</li>
<li>节制食物会让我们身体健康，节制与人交往会让我们心灵平静。</li>
<li>因此谁在早年就喜欢上独处，他就不音获得了一个金矿。 当然，不是行一个人都能够这样做。这是因为正如人们当初受到资乏的驱赶而聚集在一起，一且解决了匮乏，无聊同样会把人们驱赶到一块。没有了既乏和无聊，人们或许就会孤身独处，虽然这只是因为每个人都自认为很重要，其至认为自己是独一无二的， 而独处时，周围的环境恰好适合如此评价，因为生活在拥挤、繁杂的世人中，就会变得举步维艰，痛苦掣肘不断，自己心目中的重要性就会消失殆尽。在这种意义上说，独处甚至是每一个人自然的、合适的生活状态:它使每一个人都像亚当那样重新享受原初的、与自己本性相符的幸福快乐。</li>
<li>正如一个人背负着自己的身体重负却一无所觉， 而在移动他人的身体时却感到了重量，同理，他不会注意到自己身上的缺点和恶习，只会留意他人的这些东西。因此，每个人都应该以他人为镜，从这面镜子可以清楚地看到自己的缺点、恶习及其他让人厌恶之处。不过，在大多数情况下，人们却像一条对着镜 子咆哮的狗，因为它不知道它在镜子中看着自己，而以为那是另外条狗。挑剔别人缺点差错的人也是在改进着自己。所以，倾向和习惯于在私下默默留意别人的外在行为，刻薄挑剔别人不论做过的抑或不曾做过的事情的人，也因此在改进和完善着自己，因为这种人起码有足够的公正或者足够的骄傲和虚荣心去避免做出他们经常如此严厉、苛刻批评的事情。对于那些容忍别人的人来说，则是相反，即：我们给予自己各种自由，也同样让别人有各种自由。</li>
<li>我们不应该驳斥别人的看法，而应该记住，如果试图用说话使个人放弃他所相信的种种谬误，那就算我们有玛土撒拉的寿命，也不会完成任务。另外，在与别人谈话时，我们不要试图矫正别人，尽管我们所说的话出于善意;因为冒犯和得罪别人是很容易的，但要对此作出弥补，就算并非不可能，也是相当困难的。如果我们碰巧听到别人说出的荒谬言论开始让我们生气，我们就要想象这只是一部喜剧中两个愚人之间的对话。这一事实久经证明: 谁来到这个世上，在最重要的问题上-本正经地教育人们，那么，如果他能全身而退就已经是万幸了。</li>
<li>在言词或者表情流露出愤怒或憎恨是徒劳无益的，既不智和危险，又可笑和流于俗套。所以，除了通过行动，我们永远不要以任何其他方式表现憎恨或愤怒。我们越能避免在话语和表情上表示愤怒，就越能以行动表现出来。冷血的动物才是唯一有毒的动物。</li>
<li>一个古老的作家相当确切、中肯地说过，在这世上存在三种力:精明、力量和时运。我相信时运至为重要。这是因为我们的一-生可比之于一条船的航程。 时运一-顺运或者逆运一 扮演着风的角色， 它可以迅速推前我们的航程，也可以把我们抛后老远的距离。对此，我们的努力和奋斗作用不大。也就是说，我们的努力和奋斗只是发挥桨橹的作用:在竭尽全力挥舞桨橹数小时以后，终于向前走了一程，这时突如其来的一阵强风， 一下子就能使我们倒退同样的距离。如果风向顺利，我们不需划桨也会前行。一西班牙谚语就很美妙地表达了命运的强大力量: 祝你儿子好运，然后把他抛进大海吧!</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】原子更新调研分析（一）Fedora-Silverblue初窥</title>
    <url>/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/</url>
    <content><![CDATA[<h1 id="原子更新调研分析（一）Fedora-Silverblue初窥"><a href="#原子更新调研分析（一）Fedora-Silverblue初窥" class="headerlink" title="原子更新调研分析（一）Fedora-Silverblue初窥"></a>原子更新调研分析（一）Fedora-Silverblue初窥</h1><p><em><strong>最近很大一部分时间都在开发deepin的原子更新，在闲暇时关注下其他的os原子更新的实现，从而查漏补缺完善自身的不足，本文为Fedora-Silverblue OS自身的原子更新一个大致框架介绍。</strong></em></p>
<span id="more"></span>

<h2 id="本文适读人群"><a href="#本文适读人群" class="headerlink" title="本文适读人群"></a>本文适读人群</h2><ol>
<li>对linux系统启动流程有基本认知</li>
<li>有过linux系统开发基本常识，了解sh脚本</li>
</ol>
<h2 id="本文能够知道什么"><a href="#本文能够知道什么" class="headerlink" title="本文能够知道什么"></a>本文能够知道什么</h2><ol>
<li>Fedora-Silverblue OS原子更新应用安装到启动基本流程介绍</li>
</ol>
<h2 id="本文不知道什么"><a href="#本文不知道什么" class="headerlink" title="本文不知道什么"></a>本文不知道什么</h2><ol>
<li>rpm-ostree原理及其在os使用</li>
<li>Fedora-Silverblue OS版本清除</li>
</ol>
<h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><ol>
<li><p>Fedora-Silverblue OS原子更新优势是什么？<br>详细的可以看下这篇文章，里面有详细介绍其原子更新的优势以及其特点，<a href="https://www.linkedin.com/pulse/never-worry-updates-again-ostree-zincati-kelvin-yao-fan/">Never Worry about Updates Again with OSTree and Zincati</a>。这里我大致讲一下，系统在更新时若由于应用不稳定或系统基础组件不稳定导致无法启动，可以还原至更新前的节点，原子意思为本次操作为完整并不可切分，通过原子化更新可以随时切回更新前节点。</p>
</li>
<li><p>rpm-ostree是什么<br>ostree为本地部署仓库，类似与git,但ostree针对的是本地的文件，用户可以在本地初始化仓库并将系统文件提交至此仓库中，提交过程中ostree会对提交文件进行分析，进行增量备份从而节省空间。rpm为linux系统下软件包管理工具。rpm与ostree进行结合则可以做到对每一次应用的修改都可以将其备份。详细内容见<a href="https://coreos.github.io/rpm-ostree/">rpm-ostree</a>。</p>
</li>
</ol>
<h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><ol>
<li><p>系统的<code>/boot</code>目录下存有多个initrd,若两者为相同md5值则为硬链接，系统的<code>/boot</code>，<code>/var</code>目录为单独挂载<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/1.png" alt="图1"></p>
<ul>
<li>/boot为启动分区，在系统备份时，会将备份的initrd存放至/boot分区中，并且备份的initrd无任何改变时为了节省空间会将其硬链接。</li>
</ul>
</li>
<li><p>Fedora-Silverblue利用rpm-ostree命令将其安装至系统中，但此次安装时安装时并不会立即生效，Fedora-Silverblue将系统的根分区挂载为只读，本次安装无法将应用释放至系统根目录中。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/2.png" alt="图2"></p>
</li>
<li><p>本次系统应用安装时，会将对本次安装的所有应用进行提交，包括其依赖的文件。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/3.png" alt="图3"></p>
</li>
<li><p>linux系统通过指定目标目录组成，系统在应用安装时，会对本地系统进行硬链接组成<code>sysroot</code>文件夹，此文件夹内容为当前系统以及本次安装的应用。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/4.png" alt="图4"></p>
</li>
<li><p>通过设置<code>/boot/grub2/grubenv</code>的环境变量来修改本机<code>grub</code>等待时间，在下次系统启动时，不等待grub界面直接启动系统，从而保护系统启动的安全性。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/5.png" alt="图5"></p>
</li>
<li><p>目前我们拥有了一个新的系统目录<code>sysroot</code>，os通过<code>Dracut</code>工具，可以指定<code>sysroot</code>启动本机系统详细见官方文档<code>https://man7.org/linux/man-pages/man8/dracut.8.html</code>，在启动后/sysroot进入系统后中其中文件会被清空。</p>
</li>
</ol>
<h2 id="os原子更新优劣分析"><a href="#os原子更新优劣分析" class="headerlink" title="os原子更新优劣分析"></a>os原子更新优劣分析</h2><ul>
<li><p>优点：</p>
<ul>
<li>os的根只读可以保护根系统不被破坏</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>用户无法对本次安装的应用直接使用，必须重启才能生效。</li>
<li>分区的固定性，对多种分区格式支持不太友好。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>原子更新</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】读《哲学故事》</title>
    <url>/2022/07/31/%E8%AF%BB%E5%93%B2%E5%AD%A6%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>《哲学故事》 非常难得的一本幽默诙谐又带有科普性质的哲学书籍。</strong></em></p>
<span id="more"></span>

<p>每次我看哲学书籍时就想到一句俚语，“人类一思考，上帝就发笑”，思考的价值是什么呢？哲学需要解决的问题是什么呢？我暂且想不出思考的价值，但哲学需要解决的问题大抵是“平衡”两个字就可以概括，平衡多元化的思想，让社会处于稳定而又朝气蓬勃的状态，有矛盾但不激化，有真理的存在但不笃定，时刻保持怀疑。</p>
<p>从自然界的角度来看，人类属于自然界的一个物种，他的自我感受基本都是来自与本能，就像幸福与痛苦是朋友一样，受与五体之困，倘若你是一名严重的鼻炎患者，那么正常的呼吸，睡眠普通人触手可及的东西就是你的渴望，基督教与佛教根本思想都是悲观主义，人生下有罪，在生活中不断的救赎自己。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>我知道获得荣誉和财富有很多好处，但是如果我想认真的研究新事物的话，我应该停止追求这些。一般的，一个人拥有这两样东西越多，快乐感越多，也就越想进一步增加他们。任何时候如果我们的愿望遭受了挫折，我们也会遭受极大的痛苦。名誉也一样：如果我们盲目的追求欲望，那我们必须调整我们生活的方向，取悦别人，不能惹人讨厌，还要揣摩别人喜欢什么。但是对一件永恒且无穷的事物的热爱能使我们思想享受愉悦，避免所有的痛苦。</li>
<li>同一天，我和他的邻居，一个老妇人聊天，我问地，是不是因为无法知道灵魂如何产生而每天不开心。她甚至无法理解我的问题，她一生中甚至连秒钟都没有想过这样的问题，而那位善良的婆罗门长老却不断自我折磨。她内心深处相信守护神的化身，如果她能够得到恒河的圣水洗礼沐浴，她就认为自己是最幸福的女人。我为这个可怜人的幸福感到惊讶。我回到哲学家那里，我说:“离你不到五十码的地方，一位老妇人什么都不想而活得很快乐，你不为你如此痛苦而羞愧吗?“，他答道:“你说得对，我对我自己说了一千遍了，如果我能和那个老邻居一样无知，我应该也很快乐。但是那并不是我想要的快乐“。</li>
<li>人生是不幸的，因为痛苦是人生最基本的刺激与实在，而愉悦是痛苦的片段，其作用是消极的。亚里士多德说的对，智者不追求愉悦，他们在忧虑与痛苦中追寻自由。</li>
<li>不论婚前还是婚后，我们都不幸福:不论独处还是群居，我们都不快乐。我们就像一群为了抵御严寒而聚在一一起的刺猬，靠得近了，不舒服，离得远了，又冷得刺骨。人生真是有趣!“ 如果我们纵观整个人生而且把焦点放在人生那些最显著的特征上，我们会发现人生其实就是一场悲剧，但如果我们细细观察，人生又充满了喜剧的种种特征。</li>
<li>爱远方的人，胜过爱你的邻居。</li>
<li>有一次潘格洛斯对老实人说:“在这个所有可能世界中最好的世界里，事情都是相互关联的，如果你没有被带离那座宏伟的城堡….如果你没有被送去异教审判…..如果你没有走遍美洲…如果你没有失去所有的金….你就不会在这里吃着香橼和阿月浑子果仁了。老实人回答说:“所有那些都很好， 但是我们还是去我们的园子种植吧。</li>
</ul>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>我们应该怎么做呢？我想我们应该坚持自己的理想与追求，保持自我内心的平衡，进行适当的锻炼并保持规律的作息，让身体对外界的压力有一定的弹力，从而能进行更好的思想上的思考与精神上追求。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】科学上网简单搭建</title>
    <url>/2022/07/03/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="linux下科学上网简单搭建"><a href="#linux下科学上网简单搭建" class="headerlink" title="linux下科学上网简单搭建"></a>linux下科学上网简单搭建</h1><p><em><strong>linux下利用shadowsock+kcptun+udp2raw的科学上网搭建。</strong></em></p>
<span id="more"></span>
<h2 id="本文适读人群"><a href="#本文适读人群" class="headerlink" title="本文适读人群"></a>本文适读人群</h2><ol>
<li>对linux服务有简单了解</li>
<li>对科学上网稳定性有强迫，在使用shadowsock+kcptun+udp2raw会让科学上网非常稳定不容易掉包</li>
</ol>
<h2 id="本文能够知道什么"><a href="#本文能够知道什么" class="headerlink" title="本文能够知道什么"></a>本文能够知道什么</h2><ol>
<li>linux下成功使用shadowsock+kcptun+udp2raw搭建科学上网</li>
</ol>
<h2 id="本文不知道什么"><a href="#本文不知道什么" class="headerlink" title="本文不知道什么"></a>本文不知道什么</h2><ol>
<li>搭建工具原理</li>
</ol>
<h2 id="VPS购买"><a href="#VPS购买" class="headerlink" title="VPS购买"></a>VPS购买</h2><ol>
<li>我买的是<a href="https://m.do.co/c/417ce18c978d/">digitalocean</a>价格在5刀一个月偏贵，只要是国外服务器就行。</li>
</ol>
<h2 id="shadowsock搭建"><a href="#shadowsock搭建" class="headerlink" title="shadowsock搭建"></a>shadowsock搭建</h2><ol>
<li><p>下载shadowsock已发布的版本<code>https://github.com/shadowsocks/shadowsocks-rust/releases</code>，找一个最新版本下载即可，或者用命令<code> wget https://github.com/shadowsocks/shadowsocks-rust/releases/download/v1.6.10/shadowsocks-v1.6.10-release.x86_64-unknown-linux-musl.tar.xz</code>即可下载至本地;</p>
</li>
<li><p>本地压缩包解压后我们要使用的有两个文件，ssserver：shadowsock的服务端，sslocal：shadowsock的客户端;</p>
<h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3></li>
<li><p>将<code>sslocal</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp sslocal /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建配置文件</p>
<blockquote>
<p>sudo vim /etc/shadowsocks.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;server_port&quot;:30001,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:9872,</span><br><span class="line">    &quot;password&quot;:&quot;rtqqer190&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/ss-server.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;shadowsocks server daemon</span><br><span class="line">After&#x3D;syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line"># 关键就是这行，确定我们的程序文件，以及配置文件的路径</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;sslocal -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start ss-server.service<br>systemctl enable ss-server.service</p>
</blockquote>
</li>
</ol>
<h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol>
<li>将<code>ssserver</code>二进制拷贝至<code>/usr/local/bin/</code>下<blockquote>
<p>sudo cp ssserver /usr/local/bin</p>
</blockquote>
</li>
<li>创建配置文件<blockquote>
<p>sudo vim /etc/shadowsocks.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;::&quot;,</span><br><span class="line">    &quot;server_port&quot;:39201,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;rtqqer190&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建开机启动服务<blockquote>
<p>sudo vim /lib/systemd/system/ss-server.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;shadowsocks server daemon</span><br><span class="line">After&#x3D;syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 关键就是这行，确定我们的程序文件，以及配置文件的路径</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li>启动服务并设置开机启动<blockquote>
<p>systemctl start ss-server.service<br>systemctl enable ss-server.service</p>
</blockquote>
</li>
</ol>
<h2 id="kcptun搭建"><a href="#kcptun搭建" class="headerlink" title="kcptun搭建"></a>kcptun搭建</h2><ol>
<li><p>下载kcptun已发布的版本<code>https://github.com/xtaci/kcptun/releases</code>，找一个最新版本下载即可，或者用命令<code>wget https://github.com/xtaci/kcptun/releases/download/v20220628/kcptun-linux-amd64-20220628.tar.gz</code>即可下载至本地;</p>
</li>
<li><p>本地压缩包解压后我们要使用的有两个文件，server_linux_amd64：kcptun的服务端，client_linux_amd64：kcptun的客户端;</p>
<h3 id="客户端配置-1"><a href="#客户端配置-1" class="headerlink" title="客户端配置"></a>客户端配置</h3></li>
<li><p>将<code>client_linux_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp client_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/kcptun.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;kcptun-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;client_linux_amd64 -l :30001 -r 127.0.0.1:30001 --crypt salsa20 --key &quot;lch0719&quot; --nocomp</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start kcptun.service<br>systemctl enable kcptun.service</p>
</blockquote>
</li>
</ol>
<h3 id="服务端配置-1"><a href="#服务端配置-1" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol>
<li><p>将<code>server_linux_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp server_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建配置文件</p>
<blockquote>
<p>sudo vim /etc/kcptun.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;listen&quot;:&quot;:8400&quot;,</span><br><span class="line">  &quot;target&quot;:&quot;127.0.0.1:39201&quot;,</span><br><span class="line">  &quot;crypt&quot;:&quot;salsa20&quot;,</span><br><span class="line">  &quot;mode&quot;:&quot;fast2&quot;,</span><br><span class="line">  &quot;key&quot;:&quot;lch0719&quot;,</span><br><span class="line">  &quot;nocomp&quot;:true,</span><br><span class="line">  &quot;keepalive&quot;:10,</span><br><span class="line">  &quot;nodelay&quot;:0,</span><br><span class="line">  &quot;mtu&quot;:1350,</span><br><span class="line">  &quot;dscp&quot;:0,</span><br><span class="line">  &quot;sockbuf&quot;:4194304,</span><br><span class="line">  &quot;nc&quot;:1,</span><br><span class="line">  &quot;resend&quot;:2,</span><br><span class="line">  &quot;parityshard&quot;:3,</span><br><span class="line">  &quot;rcvwnd&quot;:4096,</span><br><span class="line">  &quot;interval&quot;:20,</span><br><span class="line">  &quot;sndwnd&quot;:4096,</span><br><span class="line">  &quot;datashard&quot;:10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/kcptun.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;kcptun-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;kcptun -c &#x2F;etc&#x2F;kcptun.json</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start kcptun.service<br>systemctl enable kcptun.service</p>
</blockquote>
</li>
</ol>
<h2 id="udp2raw搭建"><a href="#udp2raw搭建" class="headerlink" title="udp2raw搭建"></a>udp2raw搭建</h2><ol>
<li><p>下载udp2raw已发布的版本<code>https://github.com/wangyu-/udp2raw-tunnel</code>，找一个最新版本下载即可;</p>
</li>
<li><p>本地压缩包解压后我们要使用指定架构版本<code>udp2raw_amd64</code>，udp2raw为服务端客户端一体;</p>
<h3 id="客户端配置-2"><a href="#客户端配置-2" class="headerlink" title="客户端配置"></a>客户端配置</h3></li>
<li><p>将<code>udp2raw_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp client_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/udp2raw.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;udp2raw-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;udp2raw_amd64 -c -l0.0.0.0:30001 -r &lt;服务器ip地址&gt;:&lt;服务器udp端口，比如我这里就是：4096&gt; -k &quot;lch0719&quot;</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start udp2raw.service<br>systemctl enable udp2raw.service</p>
</blockquote>
</li>
</ol>
<h3 id="服务端配置-2"><a href="#服务端配置-2" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol>
<li><p>将<code>udp2raw_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp server_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/udp2raw.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;udp2raw-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;udp2raw_amd64 -s -l0.0.0.0:4096 -r127.0.0.1:8400 -a -k &quot;lch0719&quot;</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start udp2raw.service<br>systemctl enable udp2raw.service</p>
</blockquote>
</li>
</ol>
<h2 id="谷歌设置shadowsock"><a href="#谷歌设置shadowsock" class="headerlink" title="谷歌设置shadowsock"></a>谷歌设置shadowsock</h2><ol>
<li>首先下载谷歌插件<code>SwitchyOmega</code></li>
<li><code>auto switch</code>配置规则列表网址<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code></li>
<li><code>proxy</code> 配置代理协议<code>Sock5</code>，代理服务器<code>127.0.0.1</code>，代理端口为刚才shadowsock端口<code>9872</code></li>
<li>不代理列表配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1</span><br><span class="line">::1</span><br><span class="line">localhost</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="终端配置科学上网"><a href="#终端配置科学上网" class="headerlink" title="终端配置科学上网"></a>终端配置科学上网</h2><blockquote>
<p>sudo apt install proxychains4<br>sudo vim /etc/proxychains4.conf<br>在[Proxylist]下增加：sock4 127.0.0.1 9872</p>
</blockquote>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【思考】浅谈欲望</title>
    <url>/2022/05/30/%E6%B5%85%E8%B0%88%E6%AC%B2%E6%9C%9B/</url>
    <content><![CDATA[<h1 id="浅谈个人欲望"><a href="#浅谈个人欲望" class="headerlink" title="浅谈个人欲望"></a>浅谈个人欲望</h1><p><strong>Don’t stretch your desire towards it, but wait till it reaches you. Do this with regard to children, to a wife, to careers, to riches, and you will eventually be a worthy partner of the feasts of the gods.</strong></p>
<span id="more"></span>

<p>最近在看西方哲学史，对自我的理解加深了一些，对于自我本身的欲望有所感慨。以下全为对自我的感慨;</p>
<h2 id="欲望的分类"><a href="#欲望的分类" class="headerlink" title="欲望的分类"></a>欲望的分类</h2><p>欲望分为本能欲望，物质欲望，思想欲望。本能欲望是指作为一碳基生物所需要的生存本能，例如我们需要呼吸，吃饭，睡觉，属于我们生活不可获取的欲望，物质欲望是指脱离了生存本能而想获取的那部分，比如高质量的生活追求，放飞自我的日程安排，思想欲望则是追求心理的平静，知识的汲取和人性的思考等等;</p>
<h2 id="通过欲望获取快乐"><a href="#通过欲望获取快乐" class="headerlink" title="通过欲望获取快乐"></a>通过欲望获取快乐</h2><p>通过欲望而获取快乐，分为三层，第一层是需求，想获取对于个人暂时无法获取的事物，从而产生了欲望，最后通过努力获取后得到物质的满足获取了快乐;第二层是克制，通过控制自我，掌握自身习惯与特性降低自身欲望，当个体长期对单一事件得不到满足就会对产生欲望，此时对欲望进行满足则会获取到快乐，第三层是无欲无求，当个体没有欲望后就不需要通过快乐进行满足自身，个人如果对生命没有渴求，自然不会畏惧死亡，没有恐惧就不会获取到快乐，但从人这个角度来看，本能的欲望很难克制，无法克制自身欲望就不能保持精神的纯洁。在对事物进行思考的时，会被肉体的饥饿，疲惫，困顿而影响，从而得不到纯粹的思想上的答案。所以西方哲学家普遍认为死亡，才能获取到精神的纯洁，才能接触到真正的智慧。</p>
<p><img src="/2022/05/30/%E6%B5%85%E8%B0%88%E6%AC%B2%E6%9C%9B/1.jpg" alt="图1"></p>
]]></content>
      <categories>
        <category>自我反思</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>【运动】慢跑</title>
    <url>/2022/05/02/%E6%B5%85%E8%B0%88%E5%A6%82%E4%BD%95%E6%85%A2%E8%B7%91/</url>
    <content><![CDATA[<h1 id="浅谈如何坚持慢跑"><a href="#浅谈如何坚持慢跑" class="headerlink" title="浅谈如何坚持慢跑"></a>浅谈如何坚持慢跑</h1><span id="more"></span>

<h2 id="本人经历"><a href="#本人经历" class="headerlink" title="本人经历"></a>本人经历</h2><h3 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h3><p>在高中的时候注意到每天早上运动一小会，会让自己一天感觉精神充沛，所以当时在高三的每天早上会下楼围绕我们400m的操场进行慢跑6～8圈，持续20～30分钟，约莫坚持了三个月，当时身体状态较为良好，没有注意跑步姿势也没考虑很多，有多打挎就迈多大步子。</p>
<h3 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h3><p>但上大学的大二暑假，意识到自己这个行业是个高危行业，需要保持身体的健康，于是每天晚上进行夜跑，在4.5km左右，当时已经意识到自己身体状况大不如从前，就琢磨一套跑步小技巧，一直沿用至今，从上班这几年断断续续的跑步情况来看，小技巧对于慢跑还是很有帮助的;</p>
<ul>
<li><p>慢跑的时候首先需要考虑，运动的手段有很多，我真的需要通过慢跑这一项来减肥/维持健康/锻炼身体么？，慢跑是一个长时间的有氧运动过程，对我而言是快乐而又痛苦，能够清晰的感受到身体的每个部位的疲惫，所以在下定决心慢跑时，需要做好考虑;</p>
</li>
<li><p>需要一双专业跑鞋，如果穿板鞋or篮球鞋对于跑路来说是对自身脚的一种折磨</p>
</li>
<li><p>每当我跑步之前我会约定本次跑步的公里数，并不会规定本次跑步的时，要清晰的记住自己为何要慢跑，即使我跑步动也会把剩余公里走完;</p>
</li>
<li><p>在跑步之前会进行快走热身，在跑的前四分之一的时候，我会遵循七步一吸，七步一呼，把身体匀速拉到慢跑的节奏上;</p>
</li>
<li><p>我会对总路程进行标记，每当到四分之一，二分之一时，会对自己进行催眠告诉自己很快就要到达目的地;</p>
</li>
<li><p>在跑步的时候我会进行思考，会思考一些关于工作，生活，之类的东西，会让自己不去想为什么腿这么疲惫，为什么呼吸跟不上节奏，通常如果在思考阶段，对于我来说跑步会过的很快;</p>
</li>
<li><p>慢跑需要坚持一定的频率，比如一周要进行3次，不然你的腿会跟不上你的胃;</p>
</li>
<li><p>如果才开始慢跑，或者长时间没有慢跑，可以进行分段式跑步，在进行两公里的慢跑后，身体素质跟不上，需要将自己速度调整至快走的速度，缓过来后再进行慢跑，当然慢跑频率越高掌控节奏越好就不会存在此问题了;</p>
</li>
</ul>
<p>多看书多看报，少吃零食多运动。<br><img src="/2022/05/02/%E6%B5%85%E8%B0%88%E5%A6%82%E4%BD%95%E6%85%A2%E8%B7%91/1.jpg" alt="图1"></p>
]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】UOS下搭建latex</title>
    <url>/2022/03/24/UOS%E6%90%AD%E5%BB%BAlatex/</url>
    <content><![CDATA[<h1 id="UOS系统下搭建latex环境"><a href="#UOS系统下搭建latex环境" class="headerlink" title="UOS系统下搭建latex环境"></a>UOS系统下搭建latex环境</h1><p><em><strong>UOS系统下搭建latex并使用plantuml进行绘图。</strong></em></p>
<span id="more"></span>
<h2 id="本文适读人群"><a href="#本文适读人群" class="headerlink" title="本文适读人群"></a>本文适读人群</h2><ol>
<li>有linux下使用vscode开发经验</li>
<li>了解linux下环境变量原理以及设置</li>
</ol>
<h2 id="本文能够知道什么"><a href="#本文能够知道什么" class="headerlink" title="本文能够知道什么"></a>本文能够知道什么</h2><ol>
<li>latex的搭建</li>
<li>latex中使用plantuml</li>
<li>vscode如何使用latex</li>
</ol>
<h2 id="本文不知道什么"><a href="#本文不知道什么" class="headerlink" title="本文不知道什么"></a>本文不知道什么</h2><ol>
<li>latex的语法</li>
<li>plantuml的搭建</li>
</ol>
<h2 id="latex的安装"><a href="#latex的安装" class="headerlink" title="latex的安装"></a>latex的安装</h2><ol>
<li><p>在官网对<code>Tex Live</code>进行下载，<a href="https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz">下载链接</a>。下载之后会得到一个install-tl-unx.tar.gz，解压之后获取install-tl，直接运行输入I即可安装。不推荐使用命令安装<code>sudo apt install texlive-full</code>，debian上游的版本太老。</p>
</li>
<li><p>将已安装成功的texlive路径加入至环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MANPATH&#x3D;$&#123;MANPATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2021&#x2F;texmf-dist&#x2F;doc&#x2F;man</span><br><span class="line">export INFOPATH&#x3D;$&#123;INFOPATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2021&#x2F;texmf-dist&#x2F;doc&#x2F;info</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2021&#x2F;bin&#x2F;x86_64-linux</span><br></pre></td></tr></table></figure>
<p><del>2. 将已安装成功的texlive的可执行程序软链放入<code>/usr/bin</code>中，如果用其他的都可放入</del>s</p>
</li>
<li><p>调用<code>tex --version</code>，有版本信息则是调用成功</p>
</li>
</ol>
<h2 id="latex引用包配置"><a href="#latex引用包配置" class="headerlink" title="latex引用包配置"></a>latex引用包配置</h2><ol>
<li>查看本地包存放地址 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kpsewhich -var-value&#x3D;TEXMFHOME</span><br></pre></td></tr></table></figure></li>
<li>将引用包存放至本地目录，在开发tex文件时，就可以找到了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境变量为 &#x2F;home&#x2F;mecry&#x2F;texmf, 自定义包存放至&#x2F;home&#x2F;mecry&#x2F;texmf&#x2F;tex&#x2F;latex&#x2F;目录下</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vscode的配置"><a href="#vscode的配置" class="headerlink" title="vscode的配置"></a>vscode的配置</h2><ol>
<li>在vscode扩展商店中安装<code>LaTeX Workshop</code>和<code>LaTeX Utilities</code>扩展插件</li>
<li>在vsocde首选项设置中搜索<code>latex-workshop.latex.tools</code>，点击setting进行设置</li>
<li>增加以下配置,此配置只针对lualatex，当vscode进行编译时调用的就是lualatex <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;lualatex-&gt;biber-&gt;lualatex&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;lualatex&quot;,</span><br><span class="line">            &quot;biber&quot;,</span><br><span class="line">            &quot;lualatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;lualatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;lualatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">            &quot;-shell-escape&quot;,</span><br><span class="line">            &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;-pdf&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;biber&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;biber&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">&quot;window.zoomLevel&quot;: -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>latex-workshop.latex.tools：编译工具选项，也就是我们上面在 Build LaTex project 下拉菜单看到的，只要在这里配置了 tools ，就会新增到下拉菜单里供我们选择。</li>
<li>latex-workshop.latex.recipes：配置每一个编译的小环境。</li>
</ul>
</li>
</ol>
<h2 id="latex中使用plantuml"><a href="#latex中使用plantuml" class="headerlink" title="latex中使用plantuml"></a>latex中使用plantuml</h2><ol>
<li>首先需要将本机的plantuml环境搭建成功，此文档不进行赘述默认已完成安装</li>
<li>在plant<a href="https://plantuml.com/starting">官网</a>下载对应的jar扩展包</li>
<li>调用命令下载plantuml脚本 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install plantuml</span><br></pre></td></tr></table></figure></li>
<li>编辑<code>/usr/bin/plantuml</code>脚本，将本机下载的<code>plantuml.jar</code>路径进行编辑，将<code>$JAVA</code>开头这句话进行替换 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JAVA -Djava.net.useSystemProxies&#x3D;true $HEADLESS -jar &quot;&#x2F;usr&#x2F;share&#x2F;plantuml&#x2F;plantuml.jar&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>
 <code>-Djava.net.useSystemProxies=true $HEADLESS</code>这句话影响plantuml颜色，不加就会是黑白的，<code>/usr/share/plantuml/plantuml.jar</code>这个路径为系统的plantuml.jar路径，将第二步下载的文件进行替换。</li>
<li>编辑<code>/usr/share/texlive/texmf-dist/tex/lualatex/plantuml/plantuml.lua</code>脚本，将其<code>plantuml</code>路径进行替换 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--local plantUmlJar &#x3D; os.getenv(&quot;PLANTUML_JAR&quot;)</span><br><span class="line">--if not plantUmlJar then</span><br><span class="line">    --texio.write_nl(&quot;Environment variable PLANTUML_JAR not set.&quot;)</span><br><span class="line">    --return</span><br><span class="line">--end</span><br></pre></td></tr></table></figure>
 注释plantumljar <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">texio.write(&quot;Executing PlantUML... &quot;)</span><br><span class="line">--  local cmd &#x3D; &quot;java -jar &quot; .. plantUmlJar .. &quot; -t&quot;</span><br><span class="line">local cmd &#x3D; &quot;plantuml -charset UTF-8 -t&quot;</span><br></pre></td></tr></table></figure>
 将plantuml加入至cmd命令中并加上<code>-charset UTF-8 -t</code>，处理中文问题。</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】读《倦怠社会》</title>
    <url>/2022/02/28/%E8%AF%BB%E5%80%A6%E6%80%A0%E7%A4%BE%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>《倦怠社会》一本现代主义的躺平之书。 —–有时候不要光叫口号，还得补充补充理论知识。</strong></em></p>
<span id="more"></span>

<p>过年来到现在太忙了，很难抽出时间阅读些长篇大论，顺手把那本小本的《倦怠社会》抽半天时间看了，没想到感觉还不错。躺平口号贯彻我朋友圈，但都是喊口号，真躺的还真没几个，这本书就对”躺平“这个一概念进行详解，讲讲为什么躺平，躺平的优势，全世界都躺平会发生什么，建议喊口号的的人手一本熟读贯通。</p>
<p>开篇就讲卡夫卡对普罗米修斯和老鹰故事的理解，伤口为什么愈合了？老鹰为什么不继续折磨普罗米修斯？是因为伤口倦怠了，在倦怠中愈合，老鹰也倦怠了，在倦怠中不愿意折磨了。</p>
<p>读完之后我认为人从精神层面上是可以倦怠的，倦怠是一种奖励机制，一种免疫机制，就像你如果拥有强壮的身体，感冒就会随之而去，如果你是一个精神富足的人，焦虑/疲惫/愤怒也会随着你自我调节的倦怠随之而去。生活不止需要物质上的富足，也需要精神上的富足，对个体而言精神上的富足比物质富足重要的多，倦怠赋予人们一种特殊的舒适，一种放松的无为。在这种情况下，各种观感并没有变得疲惫，而是唤起了一种特殊的视觉能力。在平常生活中追求效率的时候，会忽略这种形态，疲惫的奥德修斯赢得了乌西卡的爱情，疲惫可以让人获取从未拥有过的年轻，从心理上。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>在理想自我面前，真实的自我是一个失败者，他被淹没在自怨自艾中。自我同自身发动战争。在这场战争中没有胜利者，因为胜利者意味着胜利者死亡。</li>
<li>如果人们为了生命的缘故而否认疾病，那么这种遗世独立的生命，盲目的摆脱了其他的一切因素，也将因此转向毁灭和罪恶，走向无耻和自鸣得意。如果有人憎恶毁灭，那么他必须同时厌恶生命，因为死亡才等于永不衰退的生命。</li>
<li>期望不断提升，任何一次经历都无法带来满足，相应的，没有能力去完成任何一件事情。完成某项任务的满足感被屏蔽了，因为这种感觉使个人的经历具象化，使其拥有了形态和外貌，从而脱离自我获得独立的存在。</li>
<li>新自由主义导致了大量不平等，他不是美的政体。英语中fair一词表示“公正”，也表示“美”</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【旅游】武当山行</title>
    <url>/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="初五登武当山记"><a href="#初五登武当山记" class="headerlink" title="初五登武当山记"></a>初五登武当山记</h1><span id="more"></span>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过年进食太多就想去运动一下，正好听说武当山下雪景色别有一番风味，就约朋友几个一起上一下武当山。<br><img src="/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/%E5%9B%BE1.jpg" alt="图1"><br><img src="/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/%E5%9B%BE2.jpg" alt="图2"><br><img src="/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/%E5%9B%BE3.jpg" alt="图3"></p>
<p>总结：初五武当山人太多了，特别是金顶，2个多小时上山，但是在金顶排队了一个多小时，全都是来金顶烧香的。</p>
]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】X11学习（二）实现系统级别光标转圈</title>
    <url>/2021/12/31/X11%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%85%89%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E8%BD%AC%E5%9C%88/</url>
    <content><![CDATA[<h1 id="X11基础学习（二）实现系统级别光标转圈"><a href="#X11基础学习（二）实现系统级别光标转圈" class="headerlink" title="X11基础学习（二）实现系统级别光标转圈"></a>X11基础学习（二）实现系统级别光标转圈</h1><p><em><strong>本文学习X11设置系统的光标，使其全局状态为<code>等待</code>，参考开源项目<a href="https://github.com/linuxdeepin/startdde/tree/b2fe38552c48dd1086639b55b1fcd62c0fc7e2ca/iowait">linuxdeepin/startdde</a>，中IO读写设置光标逻辑。代码已归纳至我的<a href="https://github.com/MecryWork/x11Cursor">x11Cursor</a>可以使用cmake直接编译使用</strong></em></p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>X11是什么</p>
<p> X提供了GUI一个在unix系统下基本框架，可以绘图，移动窗口，显示窗口，与鼠标键盘一系列的交互。当前X已经更新到第11版所以简称为X11协议。与其类似的可以参考Wayland</p>
</li>
</ol>
<h2 id="局部设置鼠标为转圈状态"><a href="#局部设置鼠标为转圈状态" class="headerlink" title="局部设置鼠标为转圈状态"></a>局部设置鼠标为转圈状态</h2><ol>
<li><p>setOverrideCursor</p>
<p> 在QT实现窗口上，进行全局鼠标光标加载利用<code>QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));</code>然后在使用<code>QApplication::restoreOverrideCursor();</code>对光标进行释放</p>
<h2 id="全局设置鼠标为转圈状态"><a href="#全局设置鼠标为转圈状态" class="headerlink" title="全局设置鼠标为转圈状态"></a>全局设置鼠标为转圈状态</h2></li>
<li><p>XcursorImagesLoadCursor</p>
<p> 在linux系统上观察，单一进程僵死或者无响应并不会导致光标转圈，当系统的CPU飙升时才会导致鼠标全局转圈。查看deepin的startdde中iowait代码发现存在时时监视CPU状态线程，当线程飙升时会调用<code>XcursorImagesLoadCursor + XDefineCursor + XFixesChangeCursorByName</code>函数设置光标，将光标样式设置为转圈样式就能实现</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 改变当前光标样式</span></span><br><span class="line"><span class="comment">    * @param theme &#123;const char *&#125; 选择光标主题</span></span><br><span class="line"><span class="comment">    * @param src &#123;const char *&#125; 目标样式</span></span><br><span class="line"><span class="comment"> * @param dst &#123;const char *&#125; 待修改样式</span></span><br><span class="line"><span class="comment"> * @param dst &#123;int&#125; 光标大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xc_change_cursor_by_name</span><span class="params">(Display *dpy, <span class="keyword">const</span> <span class="keyword">char</span> *theme,<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">const</span> <span class="keyword">char</span>* dst, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">-1</span>) &#123;</span><br><span class="line">		size = XcursorGetDefaultSize(dpy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load cursor images</span></span><br><span class="line">	XcursorImages *dst_images = xc_load_images(theme, dst, size);<span class="comment">//①</span></span><br><span class="line">	<span class="keyword">if</span> (!dst_images) &#123;</span><br><span class="line">		XcursorImagesDestroy(dst_images);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to load cursor images: %s/%s\n&quot;</span>, src, dst);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Cursor dst_cursor = XcursorImagesLoadCursor(dpy, dst_images);</span><br><span class="line"></span><br><span class="line">	Window root = XDefaultRootWindow(dpy);</span><br><span class="line">	XUndefineCursor(dpy, root);</span><br><span class="line">	XDefineCursor(dpy, root, dst_cursor);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Will change cursor: %s --&gt; %lu(%s)\n&quot;</span>, src, dst_cursor, dst);</span><br><span class="line">	XFixesChangeCursorByName(dpy, dst_cursor, src);<span class="comment">//更改光标样式</span></span><br><span class="line"></span><br><span class="line">	XcursorImagesDestroy(dst_images);</span><br><span class="line">	XFreeCursor(dpy, dst_cursor);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ①： Xcursor (mostly) follows the freedesktop.org spec for theming icons. The default search path it uses is ~/.local/share/icons, ~/.icons, /usr/share/icons, /usr/share/pixmaps. Within each of these directories, it searches for a directory using the theme name. Within the theme directory, it looks for cursor files in the ‘cursors’ subdirectory. It uses the first cursor file found along the path.<br> If necessary, Xcursor also looks for a “index.theme” file in each theme directory to find inherited themes and searches along the path for those themes as well.</p>
<p> If no theme is set, or if no cursor is found for the specified theme, Xcursor checks the “default” theme.</p>
<p> 上述为官方对them介绍，简而言之就是当你参数传入时他会从<code>~/.local/share/icons, ~/.icons, /usr/share/icons, /usr/share/pixmaps.</code>路径查找目标主题然后加载光标，如果主题不存在的设置为<code>default</code></p>
<h2 id="隐藏光标"><a href="#隐藏光标" class="headerlink" title="隐藏光标"></a>隐藏光标</h2></li>
<li><p>XFixesHideCursor</p>
<p> 隐藏光标原理是将光标设置为<code>x11 null cursor</code>,设置光标方法和上面一样，当不需要隐藏时就设置<code>x11 left_ptr cursor</code>进行还原。如下为创建光标为NULL</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">window = DefaultRootWindow(display);</span><br><span class="line">Cursor invisibleCursor;</span><br><span class="line">Pixmap bitmap;</span><br><span class="line">XColor black;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> data[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">black.red = black.green = black.blue = <span class="number">0</span>;</span><br><span class="line">bitmap = XCreateBitmapFromData(display, window, data, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">invisibleCursor = XCreatePixmapCursor(display, bitmap, bitmap, &amp;black, &amp;black, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p> 如果不想用上述方法对光标进行设置，可以用<code>libxfixes</code>库进行光标隐藏和显示</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void XFixesHideCursor (Display *dpy, Window win);</span><br><span class="line">void XFixesShowCursor (Display *dpy, Window win);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>X11学习</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】摘要《人生十大法则》</title>
    <url>/2021/12/06/%E4%BA%BA%E7%94%9F%E5%8D%81%E5%A4%A7%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>如果你的生活不尽如人意，试着说真话;如果你拼命地坚持某种意识或者沉迷于虚无主义，试着说真话;如果你感到脆弱、无用、绝望和困惑，试着说真话。</strong></em></p>
<span id="more"></span>

<h2 id="猴子"><a href="#猴子" class="headerlink" title="猴子"></a>猴子</h2><p>如果你想捕捉猴子，你需要找一个大的窄口瓶，瓶子口刚好可以让猴子的手正好伸进去。然后把瓶子装些石头，直到猴子无法拎起来，并且把食物放在瓶子中。猴子过来就会抓起瓶子的食物，但是因为握着食物，无法将手从瓶子抽出来，除非他选择放手，猴子肯定不会这么做，于是捕捉者就可以大摇大摆的把猴子抓起来。</p>
<h2 id="猛犸象"><a href="#猛犸象" class="headerlink" title="猛犸象"></a>猛犸象</h2><p>人类在捕捉猛犸象的时候吃不完的部分会留下来存储今后使用，一开始时候是偶然价值但是人们逐渐发现了这一举动的价值，就会产生一个概念：虽然我现在想把所有食物都吃掉，但是如果省下来一部分可以保证下次不会挨饿，这种概念升级：我没法吃掉整条猛犸象，我也不能存储，但我可以把我的食物都分出去可以保证下次我挨饿的时候会有人照顾我。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li><p>我应该如何使自己变得更强大?不要撒说或做你都夷的事情。我应该如何使自己变得更高尚?只遵照你心灵的旨意行事。</p>
</li>
<li><p>找应该如何面对最辣手的问题?将它们视为通向人生之道的大门。</p>
</li>
<li><p>我应该如何帮助落魄的人?用正确的示范来鼓舞他，使他重新振作起来。</p>
</li>
<li><p>当众人皆醉我独醒时应该做什么?坚定勇敢地说出事实的真相。</p>
</li>
<li><p>我们意识得到自己的无助、局限和死亡，也可以感受到疼痛、自厌、羞耻和恐惧。我们知道什么会让我们痛苦，如何让我们痛苦，甚至怎样让别人痛苦</p>
</li>
<li><p>人们天生喜欢秩序，在秩序中人们可以做长远打算，感到稳定、平静和自信，因此我们都倾向于留在熟悉的地方，坚持已有的思想观念。</p>
</li>
<li><p>如果你的生活不尽如人意，试着说真话;如果你拼命地坚持某种意识或者沉迷于虚无主义，试着说真话;如果你感到脆弱、无用、绝望和困惑，试着说真话。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】X11学习（一）基本窗口的建立</title>
    <url>/2021/10/26/X11%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<h1 id="X11学习（一）基本窗口的建立"><a href="#X11学习（一）基本窗口的建立" class="headerlink" title="X11学习（一）基本窗口的建立"></a>X11学习（一）基本窗口的建立</h1><p><em><strong><a href="http://mech.math.msu.su/~vvb/2course/Borisenko/CppProjects/GWindow/xintro.html">http://mech.math.msu.su/~vvb/2course/Borisenko/CppProjects/GWindow/xintro.html</a>.</strong></em></p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>X11是什么</p>
<p> X提供了GUI一个在unix系统下基本框架，可以绘图，移动窗口，显示窗口，与鼠标键盘一系列的交互。当前X已经更新到第11版所以简称为X11协议。与其类似的可以参考Wayland</p>
</li>
</ol>
<h2 id="窗口的初始化"><a href="#窗口的初始化" class="headerlink" title="窗口的初始化"></a>窗口的初始化</h2><ol>
<li><p>XOpenDisplay</p>
<p> func：Display *XOpenDisplay(char *display_name);</p>
<p> 作用：打开指定X的服务器，返回一个关于服务器的display结构体。参数传入为NULL则是本机环境，如果是局域网地址则可以通过:来隔开，hostname:number.screen_number</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Display *display = XOpenDisplay(<span class="literal">NULL</span>); <span class="comment">//本机环境</span></span><br><span class="line">XOpenDisplay(<span class="string">&quot;192.168.0.12:0&quot;</span>);			<span class="comment">//局域网</span></span><br></pre></td></tr></table></figure></li>
<li><p>XCreateSimpleWindow</p>
<p> func: Window XCreateWindow(display, parent, x, y, width, height, border_width, depth, class, visual, valuemask, attributes)</p>
<p> 作用：创建一个简单窗口并返回一个窗口句柄</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Windows win = XCreateSimpleWindow(dpy, root, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xFFFF7700</span>);<span class="comment">//窗口创建</span></span><br></pre></td></tr></table></figure></li>
<li><p>XSelectInput</p>
<p> func: int XSelectInput(Display *display, Window w, long event_mask);</p>
<p> 作用： 选择窗口所需要监听的事件，第三个参数就是传入事件。否则X就不监听窗口的任何事件。</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XSelectInput(xfc-&gt;display, xfc-&gt;window, KeyPressMask);</span><br></pre></td></tr></table></figure></li>
<li><p>XMapWindow</p>
<p> func: XMapWindow(Display *display, Window w);</p>
<p> 作用： 关联并映射子窗口让其能同步获取事件和显示。</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XMapWindow(xfc-&gt;display, xfc-&gt;window);      <span class="comment">//关联窗口并显示</span></span><br></pre></td></tr></table></figure>
<h2 id="窗口事件处理"><a href="#窗口事件处理" class="headerlink" title="窗口事件处理"></a>窗口事件处理</h2></li>
<li><p>XNextEvent</p>
<p> func: XNextEvent(Display *display, XEvent)</p>
<p> 作用： 从事件队列获取下一个事件，如果队列为空则刷新缓存直到获取下一个事件。</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XEvent event = &#123;<span class="number">0</span>&#125;; <span class="comment">//X的事件</span></span><br><span class="line">      XNextEvent(xfc-&gt;display, &amp;event);<span class="comment">//拉取窗口事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;event:%d\n&quot;</span>,event.type);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="简单窗口的创建"><a href="#简单窗口的创建" class="headerlink" title="简单窗口的创建"></a>简单窗口的创建</h2><p>main.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	Display *d;</span><br><span class="line">	Window w;</span><br><span class="line">	XEvent e;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">	d = XOpenDisplay(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot open display\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s = DefaultScreen(d);</span><br><span class="line">	w = XCreateSimpleWindow(d, RootWindow(d, s), <span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xFFFF7700</span>);</span><br><span class="line">	XSelectInput(d, w, ExposureMask | KeyPressMask);</span><br><span class="line">	XMapWindow(d, w);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		XNextEvent(d, &amp;e);</span><br><span class="line">		<span class="keyword">if</span> (e.type == Expose) &#123;</span><br><span class="line">			XFillRectangle(d, w, DefaultGC(d, s), <span class="number">20</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">			XDrawString(d, w, DefaultGC(d, s), <span class="number">10</span>, <span class="number">50</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e.type == KeyPress)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	XCloseDisplay(d);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>X11学习</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【windows技术】go的http服务器响应实现</title>
    <url>/2021/10/09/go%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="go实现服务器响应客户端操作"><a href="#go实现服务器响应客户端操作" class="headerlink" title="go实现服务器响应客户端操作"></a>go实现服务器响应客户端操作</h1><p><em><strong>利用go实现服务器响应客户端各种操作</strong></em></p>
<span id="more"></span>
<h2 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h2><p>在go开发官方文档<code>https://pkg.go.dev/net/http</code>发现了针对http服务器响应和对http客户端对服务器请求的说明，本文参考此说明开始编写。</p>
<h2 id="go服务器响应"><a href="#go服务器响应" class="headerlink" title="go服务器响应"></a>go服务器响应</h2><p><em>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/foo&quot;</span>, fooHandler)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/bar&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello, %q&quot;</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<p>开发文档意思是在http服务器添加handle来响应客户端不同请求操作即可，事例函数中有两个参数需要注意:</p>
<p><code>ResponseWriter 是处理器用来创建 HTTP 响应的接口，其源码结构如下所示：</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// 用于设置/获取所有响应头信息</span></span><br><span class="line">    Header() Header</span><br><span class="line">   <span class="comment">// 用于写入数据到响应实体</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">   <span class="comment">// 用于设置响应状态码</span></span><br><span class="line">    WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Request是用来解析请求头和请求体，其源码结构如下：</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//指定请求内容例如DELETE，POST，GET</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line">	<span class="comment">//指定要请求的 URI（对于服务器请求）或要访问的 URL（用于客户请求</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">	<span class="comment">//服务器协议版本</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// &quot;HTTP/1.0&quot;</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line">	<span class="comment">//包含服务端收到或者由客户端发送的 HTTP 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line"></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line"></span><br><span class="line">    GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span></span></span><br><span class="line"></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line">    PostForm url.Values</span><br><span class="line"></span><br><span class="line">    MultipartForm *multipart.Form</span><br><span class="line"></span><br><span class="line">    Trailer Header</span><br><span class="line"></span><br><span class="line">    RemoteAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    RequestURI <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line"></span><br><span class="line">    Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Response *Response</span><br><span class="line"></span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边主要使用的就是request结构体前几个对象就可以实现了，具体的其他对象详细说明可以看下<code>request.go</code>源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    fs := http.FileServer(http.Dir(<span class="string">&quot;/home/mecry/tmp/&quot;</span>))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/&quot;</span>, <span class="built_in">delete</span>(<span class="string">&quot;/home/mecry/tmp/&quot;</span>, fs))</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;localhost:8888&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span> <span class="params">(dirprefix <span class="keyword">string</span>, next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.Method == <span class="string">&quot;DELETE&quot;</span> &#123;</span><br><span class="line">            path := dirprefix+r.URL.String()</span><br><span class="line">            fmt.Println(<span class="string">&quot;delete path:&quot;</span>, path)</span><br><span class="line">            os.Remove(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>windows技术</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用fuse实现简单文件系统</title>
    <url>/2021/09/16/%E5%88%A9%E7%94%A8fuse%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="fuse实现原理"><a href="#fuse实现原理" class="headerlink" title="fuse实现原理"></a>fuse实现原理</h1><p><em><strong><a href="http://linkmecry.cn/2021/06/07/Linux%E4%B8%8Bfuse%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">fuse原理</a></strong></em></p>
<span id="more"></span>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>周末抽了两个半天，看了下之前写的fuse总结，和之前用的httpdirfs项目中fuse实现,自己做了一个fuse的小程序，主要是对二级指针的深层次应用，源码路径<code>https://github.com/MecryWork/fuselocal</code>,功能如下</p>
<ol>
<li>实现多层次的文件和文件夹创建，重命名，删除</li>
</ol>
<p>待实现：</p>
<ol>
<li><p>文件的写入和读取（后期和服务器文件关联一下，本机的文件写入和读取有一些鸡肋）</p>
</li>
<li><p>合理的日志系统</p>
</li>
<li><p>文件创建的时间细节需要补充</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux利用fuse实现文件系统</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】cgo传入二级指针</title>
    <url>/2021/09/03/%E5%85%B3%E4%BA%8Ecgo%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="cgo实现字符串切片传入c代码中"><a href="#cgo实现字符串切片传入c代码中" class="headerlink" title="cgo实现字符串切片传入c代码中"></a>cgo实现字符串切片传入c代码中</h1><p><em><strong>go实现字符串切片传入c代码中，让c识别为二级指针，能够顺利进行字符串的偏移读写</strong></em></p>
<span id="more"></span>

<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>想通过go给C代码传入一个二级指针，然后在C中进行读取，本来以为是很简单的事情，但是发现go的string和c++的不太一样，C的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_2d_array</span><span class="params">(<span class="keyword">char</span> **arr, <span class="keyword">int</span> columeSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szBuf[<span class="number">4</span>][<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(szBuf[i], arr[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf:%s\n&quot;</span>, szBuf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一次转换的写法"><a href="#第一次转换的写法" class="headerlink" title="第一次转换的写法"></a>第一次转换的写法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteToC</span><span class="params">(list []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	dirs := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		dirs[i] = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">		dirs[i] = []<span class="keyword">byte</span>(list[i])</span><br><span class="line">		fmt.Println(<span class="string">&quot;list:&quot;</span>, list[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	C.fill_2d_array((**C.char)(unsafe.Pointer(&amp;dirs[<span class="number">0</span>][<span class="number">0</span>])), C.<span class="keyword">int</span>(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把切片转成byte传入C的代码中，但是在C代码输出的时候直接输出直接崩溃，如果按照字节处理<code>strcpy((char*)(arr+0*sizeof(char)*columeSize), &quot;hello&quot;);</code>类似这种处理，但是在C中输出的时候，字符串会或多或少，不能正常输出。</p>
<p>根因分析：之前我写过go转C++的dll，导出头文件关于GoString的定义为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GO_CGO_GOSTRING_TYPEDEF</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">const</span> <span class="keyword">char</span>* p; <span class="keyword">ptrdiff_t</span> n; &#125; _GoString_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这边我直接输出了<code>printf(&quot;%s&quot;,goString.p);</code>，然后是一串很长的字符串，详情看如何生成dll的请移步<a href="http://linkmecry.cn/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/">利用go搭建纯文件http服务器，并生成dll</a>，这边判断gostring中的p在转换的时候没有保存’\0’，意思就是没有结束符，把后面的东西全部都输出了</p>
<h3 id="第二次转换的写法"><a href="#第二次转换的写法" class="headerlink" title="第二次转换的写法"></a>第二次转换的写法</h3><p>问题找到了，只需要把’\0’在传入的时候传过去就OK，于是放弃转byte的转换方法，改用C.char*.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">charToC</span><span class="params">(list []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	nameunits := <span class="built_in">make</span>([]*C.char, <span class="built_in">len</span>(list))</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> list &#123;</span><br><span class="line">		nameunits[i] = C.CString(list[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	C.fill_2d_array((**C.char)(unsafe.Pointer(&amp;nameunits[<span class="number">0</span>])), C.<span class="keyword">int</span>(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出正常圆满完成任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf:1111</span><br><span class="line">buf:2222</span><br><span class="line">buf:3333</span><br><span class="line">buf:4444</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用C++实现链表</title>
    <url>/2021/09/03/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="利用C-实现链表基础代码"><a href="#利用C-实现链表基础代码" class="headerlink" title="利用C++实现链表基础代码"></a>利用C++实现链表基础代码</h1><p><em><strong>利用C++实现链表和CString<code>https://github.com/MecryWork/listapp</code>。</strong></em></p>
<span id="more"></span>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>实现增删改查插入</li>
<li>CString实现深拷贝</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】Valgrind检测内存泄露的学习和使用</title>
    <url>/2021/08/17/Valgrind%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Valgrind的学习和使用"><a href="#Valgrind的学习和使用" class="headerlink" title="Valgrind的学习和使用"></a>Valgrind的学习和使用</h1><p><em><strong>Valgrind 是一个 GPL 系统，用于调试和分析 Linux 程序。使用 Valgrind 的 工具，可以自动检测许多内存管理和线程错误。</strong></em></p>
<span id="more"></span>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ol>
<li><p>uos/debian/ubuntu</p>
<blockquote>
<p>sudo apt install valgrind</p>
</blockquote>
</li>
<li><p>源码安装</p>
<p> 官网<code>http://www.valgrind.org</code></p>
<p> <img src="/2021/08/17/Valgrind%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/1.png" alt="图1"></p>
<blockquote>
<p>./autogen.sh</p>
</blockquote>
<blockquote>
<p>./configure</p>
</blockquote>
<blockquote>
<p>make &amp;&amp; install</p>
</blockquote>
</li>
</ol>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ol>
<li><p>内存泄露主要使用<code>Memcheck</code>,官网介绍</p>
<p> <img src="/2021/08/17/Valgrind%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/2.png" alt="图2"></p>
</li>
</ol>
<p>解释：</p>
<ul>
<li>建立表来存储进程的地址空间，当要读写内存某个字节时，首先检查对此字节对应表的A bit，如果不存在，memcheck 则报告读写错误</li>
<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit (在 valid-value map 中) 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的 V bits，如果该值尚未初始化，则会报告使用未初始化内存错误</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="example1：内存未释放"><a href="#example1：内存未释放" class="headerlink" title="example1：内存未释放"></a>example1：内存未释放</h3><blockquote>
<p>valgrind –leak-check=yes ./main</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//未释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Command: .&#x2F;main</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;     in use at exit: 1 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;   total heap usage: 1 allocs, 0 frees, 1 bytes allocated</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; 1 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401133: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401148: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    definitely lost: 1 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>终端输出很清楚,一次获取新内存，0次释放，共有0字节为释放，然后就自动定位你未释放的地方<code>==19112==    at 0x483577F: malloc (vg_replace_malloc.c:299)</code>这句话不用看，是c底层库的东西<code>==19112==    by 0x401133: func (in /home/mecry/dde-c/metho/metho1/main)</code>这句直接指明是<code>func()</code>函数有内存泄露</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;     in use at exit: 1 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;   total heap usage: 1 allocs, 0 frees, 1 bytes allocated</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; 1 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401133: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401148: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br></pre></td></tr></table></figure>


<h3 id="example1：越界"><a href="#example1：越界" class="headerlink" title="example1：越界"></a>example1：越界</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//已释放再定义</span></span><br><span class="line">	<span class="built_in">free</span>(a);  <span class="comment">//已释放再释放</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Command: .&#x2F;main</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid write of size 4</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x401162: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 free&#39;d</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x40115D: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401143: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401173: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 free&#39;d</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x40115D: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401143: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;   total heap usage: 1 allocs, 2 frees, 4 bytes allocated</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; All heap blocks were freed -- no leaks are possible</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>写入未定义的四个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid write of size 4</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x401162: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 fre</span><br><span class="line">e&#39;d</span><br></pre></td></tr></table></figure>

<p>释放未定义的四个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401173: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 free&#39;d</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】谈谈《王朔的短篇小说》</title>
    <url>/2021/08/01/%E7%8E%8B%E6%9C%94%E7%9A%84%E7%9F%AD%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>打败你自己的只有你自己，其他人只能使你强大</strong></em></p>
<span id="more"></span>

<p>在我18年时特别迷姜文的电影和他的采访，电影是期期不落，采访的没被封的基本上都看过了，在姜文的侧面熏陶下间接的知道了王朔这个人，知道他也是一名《顽主》。从此便记下了想闲下来找他的几篇小说瞅瞅，不想一拖就是两年，说实话还是挺讽刺的上学的时候没时间看上班了为了生活还，为了充实所谓的精神世界对他的小说狂买了一通，没想到竟爱不释手。看完之后，真没想这本竟是90年代的小说，大为通透。其中大部分的小说都拍成了电影，没拍的说明不能拍或者是现在不让放了。只能引用他自己采访的一句话，<strong>我对写作是有天赋的，是生来就会不需要灵感</strong></p>
<h3 id="动物凶猛"><a href="#动物凶猛" class="headerlink" title="动物凶猛"></a>动物凶猛</h3><p>动物凶猛是被姜文改编为<code>阳光灿烂下的日子</code>，我是先看的电影再读的小说，所以在读这个时候是一边回忆我看电影的角色剧情，一边代入进小说，想<code>米兰</code>是<code>宁静</code>那样的丰满吗到底（笑），年轻的时候总是对异性抱有幻想，到底<code>马小军</code>和<code>米兰</code>发生了这么多故事么？还是都是臆想？我倒是觉得马小军自己一半臆想一半真事，他自己都说不清到底发生了什么，我觉得他对米兰的爱慕是真的，对自己的胆怯也是真的，他哪有这个胆子拿着刀去捅<code>刘忆苦</code>,只不过是在自己16，7岁认识了想<code>米兰</code>这样的性感的人儿，自己发生的幻想，对年轻女生的青少年爱情的憧憬。</p>
<h3 id="顽主"><a href="#顽主" class="headerlink" title="顽主"></a>顽主</h3><p>一看开头我就想起来了葛优的翻拍，还不止翻拍一次10年后还整了一个私人定制，不过我还是觉得第一次拍的顽主是最好的，那个经典的3T公司，为人排忧解难，刚改革开放新一代年轻人不知道干什么，在现有的生活中挣扎想混的有意义，却又不想干正事（笑），搁现在你不得为生活拼搏。3T公司是给小人物一个大人物的梦，可是之后呢，小人物还是得为自己的阶级而奋斗，所有表象,皆为虚妄，只不过是还是常常要做梦，让自己充实，如果不做梦岂不是当现实的努力，生活这么苦，跟个熟透的苦瓜一样，又苦又老，有时候还是得做做梦安慰安慰自己。</p>
<h3 id="过把瘾就死"><a href="#过把瘾就死" class="headerlink" title="过把瘾就死"></a>过把瘾就死</h3><p>杜梅想要一轰轰烈烈的爱情，想作着来，方言不明白，我也不明白，所以我不理解也不评价，只能说文字很有张力，杜梅很绝望</p>
<h3 id="一半是火焰一半是海水"><a href="#一半是火焰一半是海水" class="headerlink" title="一半是火焰一半是海水"></a>一半是火焰一半是海水</h3><p>简单的讲这个就是一个玩仙人跳的渣男，骗炮一个清纯的大学生，大学生对他不离不弃直到自杀，渣男被抓进监狱然后出狱之后幡然醒悟的故事，俗味到掉牙的老套故事。王朔在描述绝望的时候是令人窒息的，很容易把自己带入，俗套的故事不俗套的文字描述，只能说是值得一看。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>他的短篇小说太多了，我一买就买了三本合集，之后的有时间再写吧</p>
<ul>
<li>不要把心爱的东西放在身边,除非有一天你有能力保护它。——王朔《动物凶猛》</li>
<li>人都是顽固不化和自以为是的,相安无事的唯一办法就是欺骗。——王朔《动物凶猛》</li>
<li>越聊我们越觉得我们相识纯属偶然，有太多的因素可以使我们失之交臂。纯粹一念之差，邂逅了，认识了，关系进一步发展了。在此之前，我们能活到与对方相识都是侥幸。疾病、车祸以及种种意外始终威胁、伴随着我们，还有那些危险的人们。——王朔《过把瘾就死》</li>
<li>我可不喜欢什么事都清楚地知道结局，有条不紊地逐次达标，那也太乏味了。多一分远见，就少一分刺激。如果我知道下一步，每一步会碰到什么，产生什么后果，我立刻就没兴趣活了。——王朔《一半是火焰一半是海水》</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】UOS下实现键盘事件捕捉</title>
    <url>/2021/06/28/UOS%E4%B8%8B%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89/</url>
    <content><![CDATA[<h1 id="在UOS系统下实现键盘的捕捉"><a href="#在UOS系统下实现键盘的捕捉" class="headerlink" title="在UOS系统下实现键盘的捕捉"></a>在UOS系统下实现键盘的捕捉</h1><p><em><strong>在UOS系统下监听和触发键盘的事件，具体代码参考<code>https://github.com/MecryWork/hotkey</code>。参考博文<code>https://www.jianshu.com/p/927fc573d081</code></strong></em></p>
<span id="more"></span>

<h2 id="dev-input目录简介"><a href="#dev-input目录简介" class="headerlink" title="/dev/input目录简介"></a>/dev/input目录简介</h2><ol>
<li><p>首先linux是所有操作都是已文件形式处理，这个是真理。在我们输入键盘鼠标时，linux系统中记录都放在<code>/dev/input</code>目录下。我们<code>ls</code>下此目录可以看见绝大部分的事件处理</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crw-rw----  1 root input 13, 65 6月  28 13:04 event1</span><br><span class="line">crw-rw----  1 root input 13, 74 6月  28 13:04 event10</span><br><span class="line">crw-rw----  1 root input 13, 75 6月  28 13:04 event11</span><br><span class="line">crw-rw----  1 root input 13, 76 6月  28 13:04 event12</span><br><span class="line">crw-rw----  1 root input 13, 77 6月  28 13:04 event13</span><br><span class="line">crw-rw----  1 root input 13, 66 6月  28 13:04 event2</span><br><span class="line">crw-rw----  1 root input 13, 67 6月  28 13:04 event3</span><br><span class="line">crw-rw----  1 root input 13, 68 6月  28 13:04 event4</span><br><span class="line">crw-rw----  1 root input 13, 69 6月  28 13:04 event5</span><br><span class="line">crw-rw----  1 root input 13, 70 6月  28 13:04 event6</span><br><span class="line">crw-rw----  1 root input 13, 71 6月  28 13:04 event7</span><br><span class="line">crw-rw----  1 root input 13, 72 6月  28 13:04 event8</span><br><span class="line">crw-rw----  1 root input 13, 73 6月  28 13:04 event9</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>cat /proc/bus/input/devices</code>可以查看每一个event的具体操作，里面的H就是对应的时间操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I: Bus&#x3D;0000 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;HDA ATI HDMI HDMI&#x2F;DP,pcm&#x3D;3&quot;</span><br><span class="line">P: Phys&#x3D;ALSA</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:01.0&#x2F;0000:01:00.1&#x2F;sound&#x2F;card1&#x2F;input11</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event8</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;21</span><br><span class="line">B: SW&#x3D;140</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0000 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;HDA Intel PCH Rear Mic&quot;</span><br><span class="line">P: Phys&#x3D;ALSA</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:1f.3&#x2F;sound&#x2F;card0&#x2F;input12</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event9</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;21</span><br><span class="line">B: SW&#x3D;10</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0000 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;HDA Intel PCH Front Mic&quot;</span><br><span class="line">P: Phys&#x3D;ALSA</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:1f.3&#x2F;sound&#x2F;card0&#x2F;input13</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event10</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;21</span><br><span class="line">B: SW&#x3D;10</span><br></pre></td></tr></table></figure>
<h2 id="input-h-文件"><a href="#input-h-文件" class="headerlink" title="input.h 文件"></a>input.h 文件</h2></li>
<li><p>在<code>linux/input.h</code>文件中定义了<code>event</code>时间输入数据的结构图，该结构图的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line"> __u16 type;</span><br><span class="line"> __u16 code;</span><br><span class="line"> __s32 value;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds.  */</span></span><br><span class="line"> <span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds.  */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p> type，指事件类型，常见的事件类型有：</p>
<p> EV_KEY，按键事件，键盘的按键，鼠标的左键右键等；</p>
<p> EV_REL，相对坐标，主要用于鼠标的移动事件；</p>
<p> EV_ABS，绝对坐标，主要用于触摸屏的移动事件。</p>
<p> code 事件代码，当事件类型为EV_KEY时，该代码为设备键盘代码，在input.h文件中以KEY_开头定义；</p>
<p> value 事件的值，当事件类型代码是EV_KEY时，按键操作值为1，释放操作值为0，事件类型代码为EV_REL是，value为正数值和负数值分别代表连个不同方向的值。</p>
</li>
</ol>
<h2 id="监听键盘事件"><a href="#监听键盘事件" class="headerlink" title="监听键盘事件"></a>监听键盘事件</h2><ol>
<li>利用<code>input_event</code>结构体读取键盘事件 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line">fd_set readfds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd = open(dev, O_RDONLY);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(dev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(fd, &amp;readfds);</span><br><span class="line">    tv.tv_sec = timeout;<span class="comment">//设置超时时间</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((retval = select(fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.type == EV_KEY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.value == <span class="number">0</span> || event.value == <span class="number">1</span>) <span class="comment">//根据value的值判断按下松开&#123;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;key %d %s\n&quot;</span>, event.code, event.value ? <span class="string">&quot;Pressed&quot;</span> : <span class="string">&quot;Released&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;type=%x %d %d\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="传入键盘事件"><a href="#传入键盘事件" class="headerlink" title="传入键盘事件"></a>传入键盘事件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 利用`input_event`+`write`对键盘事件进行写入</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate_key</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> kval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">        gettimeofday(&amp;event.time, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//按下kval键</span></span><br><span class="line">        event.type = EV_KEY;</span><br><span class="line">        event.value = <span class="number">1</span>;</span><br><span class="line">        event.code = kval;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="comment">//同步，也就是把它报告给系统</span></span><br><span class="line">        event.type = EV_SYN;</span><br><span class="line">        event.value = <span class="number">0</span>;</span><br><span class="line">        event.code = SYN_REPORT;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        gettimeofday(&amp;event.time, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//松开kval键</span></span><br><span class="line">        event.type = EV_KEY;</span><br><span class="line">        event.value = <span class="number">0</span>;</span><br><span class="line">        event.code = kval;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="comment">//同步，也就是把它报告给系统</span></span><br><span class="line">        event.type = EV_SYN;</span><br><span class="line">        event.value = <span class="number">0</span>;</span><br><span class="line">        event.code = SYN_REPORT;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用thrift实现跨语言通讯</title>
    <url>/2021/06/17/%E5%88%A9%E7%94%A8thrift%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%AF%AD%E8%A8%80%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h1 id="blog的搭建"><a href="#blog的搭建" class="headerlink" title="blog的搭建"></a>blog的搭建</h1><p><em><strong>利用thrift的跨平台机制实现进程通讯，本机是uos系统+go语言，virtualbox是windows系统+C++，在virtualbox上增加端口转发既可实现windows与uos两者不同系统不同语言的进程通讯。</strong></em></p>
<span id="more"></span>


<h2 id="thrift简介"><a href="#thrift简介" class="headerlink" title="thrift简介"></a>thrift简介</h2><h3 id="1-理论知识"><a href="#1-理论知识" class="headerlink" title="1. 理论知识"></a>1. 理论知识</h3><pre><code>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的跨平台高效服务，可以使用C#、C++（基于POSIX兼容系统）、Cappuccino、Cocoa、Delphi、Erlang、Go、Haskell、Java、Node.js、OCaml、Perl、PHP、Python、Ruby和Smalltalk。虽然它以前是由Facebook开发的，但它现在是Apache软件基金会的开源项目了。该实现被描述在2007年4月的一篇由Facebook发表的技术论文中，该论文现由Apache掌管。
</code></pre>
<h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h3><ol>
<li>Thrift支持的基本数据类型<ul>
<li>byte: 有符号字节</li>
<li>i16: 16 位有符号整数</li>
<li>i32 : 32 位有符号整数</li>
<li>i64: 64 位有符号整数</li>
<li>double : 64 位浮点数</li>
<li>string : 字符串</li>
</ul>
</li>
<li>可用容器类型<ul>
<li>list(t): 元素类型为t的有序表，容许元素重复。</li>
<li>set(t):元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型。</li>
<li>map(t,t): 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary。</li>
</ul>
</li>
</ol>
<ol start="3">
<li>Thrift 架构（图来自于网络）<br>thrift主要用于各个服务之间的RPC通信，支持跨语言。thrift是一个典型的CS结构，客户端和服务端可以使用不同的语言开发，thrift通过IDL(Interface Description Language)来关联客户端和服务端。thrift的整体架构图如下图所示<br><img src="/2021/06/17/%E5%88%A9%E7%94%A8thrift%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%AF%AD%E8%A8%80%E9%80%9A%E8%AE%AF/1.png" alt="图1"></li>
</ol>
<h2 id="uos利用go实现thrift的客户端和服务端"><a href="#uos利用go实现thrift的客户端和服务端" class="headerlink" title="uos利用go实现thrift的客户端和服务端"></a>uos利用go实现thrift的客户端和服务端</h2><ol>
<li><p>goland安装thrift包</p>
<blockquote>
<p>go get git.apache.org/thrift.git/lib/go/thrift<br>调用命令<code>thrift -version</code>显示版本号即安装成功。</p>
</blockquote>
</li>
<li><p>下载的文件加入到<code>gopath</code>中</p>
</li>
<li><p>编写属于接口的fuse.thrift的LDL文件，我本地要实现一个剪切板数据互发功能，所以接口为剪切板功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">namespace <span class="keyword">go</span> fuse</span><br><span class="line"> service WindowsToUos &#123;</span><br><span class="line">     <span class="comment">//windows 剪切板发送到uos</span></span><br><span class="line">     <span class="keyword">bool</span> sendCliboard(<span class="number">1</span>:i32 nType, <span class="number">2</span>:<span class="keyword">string</span> path);</span><br><span class="line">     void stop();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> service UosToWindows&#123;</span><br><span class="line">     <span class="comment">//uos 剪切板发送到windows</span></span><br><span class="line">     <span class="keyword">bool</span> sendCliboard(<span class="number">1</span>:i32 nType, <span class="number">2</span>:<span class="keyword">string</span> path, <span class="number">3</span>:<span class="keyword">string</span> Vol);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在service windowstouos中，是windows为客户端，uos为服务端。在uostowindows中，是windows为服务端，uos为客户端。两者可以来回通讯。</p>
</li>
<li><p>运行命令，生成相关代码，目录下就会存在一个gen-go的一个代码文件夹</p>
<blockquote>
<p> thrift -r –gen go fuse.thrift</p>
</blockquote>
</li>
<li><p>服务端接口初始化代码如下,<code>EchoServerImp</code>接口为空接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">type</span> EchoServerImp <span class="keyword">struct</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServerStart</span><span class="params">(port <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()</span><br><span class="line">transportFactory := thrift.NewTBufferedTransportFactory(<span class="number">10000000</span>)</span><br><span class="line">serverTransport, err := thrift.NewTServerSocket(<span class="string">&quot;127.0.0.1:9150&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Error!&quot;</span>, err)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handler := &amp;EchoServerImp&#123;&#125;</span><br><span class="line">processor := fuse.NewWindowsToUosProcessor(handler)</span><br><span class="line">server := thrift.NewTSimpleServer4(processor, serverTransport, transportFactory, protocolFactory)</span><br><span class="line">fmt.Println(<span class="string">&quot;thrift server in&quot;</span>, <span class="string">&quot;127.0.0.1:9150&quot;</span>)</span><br><span class="line">server.Serve()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//	ListenClipboard()</span></span><br><span class="line">     &#125;()</span><br><span class="line">     ctxT, cancelFunc = context.WithCancel(context.Background())</span><br><span class="line">     sev := &amp;Server&#123;&#125;</span><br><span class="line">     sev.ServerStart(<span class="number">8192</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在服务端时，需要把LDL的函数实现，不然会报错，逻辑实现代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(e *EchoServerImp)</span> <span class="title">Stop</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Revice Stop!!!&quot;</span>)</span><br><span class="line">stop()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端接口初始化代码如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">clipboard <span class="comment">// interface com.deepin.ListenClipboard</span></span><br><span class="line">proxy.Object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> ClipboardService <span class="keyword">struct</span> &#123;</span><br><span class="line">     loginManager   *Manager</span><br><span class="line">     sessionSigLoop *dbusutil.SignalLoop</span><br><span class="line">     service        *dbusutil.Service</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">ListenClipboard</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> cb ClipboardService</span><br><span class="line">     <span class="comment">//注册剪切板dbus信号</span></span><br><span class="line">     sessionBus, err := dbus.SessionBus()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Warning(<span class="string">&quot;failed to register clipboard changed signal:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     cb.loginManager = NewCBManager(sessionBus)</span><br><span class="line">     cb.sessionSigLoop = dbusutil.NewSignalLoop(sessionBus, <span class="number">10</span>)</span><br><span class="line">     cb.sessionSigLoop.Start()</span><br><span class="line">     cb.loginManager.InitSignalExt(cb.sessionSigLoop, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">     <span class="comment">//绑定剪切板变化dbus信号</span></span><br><span class="line">     <span class="comment">//_, err = cb.loginManager.ConnectClipboardChange()qqq+</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Warning(<span class="string">&quot;failed to connect clipboard changed signal:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端调用服务端代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cb.loginManager.SendCliboardToWindows(clipboardType, clipboardData, vol)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="windows利用C-实现thrift的客户端和服务端"><a href="#windows利用C-实现thrift的客户端和服务端" class="headerlink" title="windows利用C++实现thrift的客户端和服务端"></a>windows利用C++实现thrift的客户端和服务端</h2><h2 id="利用virtualbox的端口转发机制，实现windows和uos互相通讯"><a href="#利用virtualbox的端口转发机制，实现windows和uos互相通讯" class="headerlink" title="利用virtualbox的端口转发机制，实现windows和uos互相通讯"></a>利用virtualbox的端口转发机制，实现windows和uos互相通讯</h2>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】Linux下fuse的实现原理</title>
    <url>/2021/06/07/Linux%E4%B8%8Bfuse%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="fuse实现原理"><a href="#fuse实现原理" class="headerlink" title="fuse实现原理"></a>fuse实现原理</h1><p><em><strong>本文是对httpdirfs源码的一个学习,源码在<code>https://github.com/fangfufu/httpdirfs</code>.实现在linux系统下利用fuse技术,把http文件服务器挂载至本地路径.</strong></em></p>
<span id="more"></span>

<h2 id="fuse原理"><a href="#fuse原理" class="headerlink" title="fuse原理"></a>fuse原理</h2><ol>
<li><p>流程介绍<br><img src="/2021/06/07/Linux%E4%B8%8Bfuse%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1.png" alt="图1"></p>
<p> 图中可以看出,fuse和ext3,ntfs都是文件系统模块.我们使用fuse实现文件系统并挂在至/tmp/fuse上,当我们对此目录执行ls命令时,内核的fuse从vfs中获取参数,调用我们自己实现ls的函数,得到结果再从vfs返回至ls.简单来说就是<code>ls-&gt;fuse挂载文件夹-&gt;VFS-&gt;libfuse-&gt;自己实现的函数-&gt;结果返回至ls</code>,demo的源码在<code>https://github.com/MecryWork/Learn-C-to-implement-fuse</code></p>
</li>
<li><p>简单demo</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUSE_USE_VERSION 26</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fuse.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> ou_re        <span class="title">addir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">void</span>* buf, <span class="keyword">fuse_fill_dir_t</span> filler,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">off_t</span> offset, struct fuse_file_info* fi)</span><span class="comment">//读取目录</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> filler(buf, <span class="string">&quot;hello-world&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ou_getattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, struct stat* st)</span><span class="comment">//获取状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		st-&gt;st_mode = <span class="number">0755</span> | S_IFDIR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		st-&gt;st_mode = <span class="number">0644</span> | S_IFREG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fuse_operations</span> <span class="title">oufs_ops</span> =</span> &#123;<span class="comment">//fuse设置响应函数</span></span><br><span class="line">	.readdir    =   ou_readdir,</span><br><span class="line">	.getattr    =   ou_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fuse_main(argc, argv, &amp;oufs_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> cmake编译成功后会看到生成的可执行文件 fusehello。建立一个挂载点 /tmp/mnt，然后运行</p>
<blockquote>
<p>./fusehello /tmp/mnt<br> 成功后试试“ls /tmp/mnt”，就能看到一个文件“hello-world”。要调试的时候可以加上“-d”选项，这样就能看到 FUSE 和自己 printf 的调试输出。代码第一行指定了要使用的 FUSE API 版本。这里使用的是 2.6 版本。</p>
</blockquote>
</li>
<li><p>简单demo2,实现创建/删除普通文件的功能,加了<code>ou_create</code>,和<code>ou_unlink</code>两个函数,在fuse上被调用.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ou_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode, struct fuse_file_info* fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ou_entry</span>* <span class="title">o</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_node</span>* <span class="title">n</span>;</span><span class="comment">//使用链表,文件放入链表中方便删除增加</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path + <span class="number">1</span>) &gt; MAX_NAMELEN)</span><br><span class="line">		<span class="keyword">return</span> -ENAMETOOLONG;</span><br><span class="line"></span><br><span class="line">	list_for_each (n, &amp;entries) &#123;</span><br><span class="line">		o = list_entry(n, struct ou_entry, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="number">1</span>, o-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ou_entry));</span><br><span class="line">	<span class="built_in">strcpy</span>(o-&gt;name, path + <span class="number">1</span>); <span class="comment">/* skip leading &#x27;/&#x27; */</span></span><br><span class="line">	o-&gt;mode = mode | S_IFREG;</span><br><span class="line">	list_add_prev(&amp;o-&gt;node, &amp;entries);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ou_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">n</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_safe (n, p, &amp;entries) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ou_entry</span>* <span class="title">o</span> =</span> list_entry(n, struct ou_entry, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="number">1</span>, o-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">			__list_del(n);</span><br><span class="line">			<span class="built_in">free</span>(o);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>总结</strong>:具体还是使用的linux中的fuse的库文件,来实现我们自己的fuse文件系统,我们只需要参照<code>fuse.h</code>文件的函数指针.需要实现哪个功能,就开始自己进行实现,最后把结构体传入至fuse,就可以成功编写一个属于我们自己的文件系统了.</li>
</ul>
<h2 id="fuse-http的实现"><a href="#fuse-http的实现" class="headerlink" title="fuse+http的实现"></a>fuse+http的实现</h2><p><strong>利用fuse的机制,再获取http接口,实现把http文件系统的文件挂载至本机指定文件夹中,虽然此程序是用纯C编写的,但是我们已知具体实现功能,并了解部分fuse实现原理,所以我们只需要解读关键函数的实现就能大致了解实现流程</strong></p>
<ol>
<li><p>link.c和link.h加载http中的Link中的路径转换至磁盘本地路径.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkTable *<span class="title">LinkTable_disk_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dirn)</span><span class="comment">//从磁盘加载链接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *metadirn = path_append(META_DIR, dirn);</span><br><span class="line">	<span class="keyword">char</span> *path;</span><br><span class="line">	<span class="comment">//http中的路径进行选择截取</span></span><br><span class="line">	<span class="keyword">if</span> (metadirn[strnlen(metadirn, MAX_PATH_LEN)] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		path = path_append(metadirn, <span class="string">&quot;.LinkTable&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		path = path_append(metadirn, <span class="string">&quot;/.LinkTable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打开路径开始获取目标文件</span></span><br><span class="line">	FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;path&lt;%s&gt;\n&quot;</span>,path);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(metadirn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">		<span class="built_in">free</span>(path);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LinkTable *linktbl = CALLOC(<span class="number">1</span>, <span class="keyword">sizeof</span>(LinkTable));</span><br><span class="line"></span><br><span class="line">	fread(&amp;linktbl-&gt;num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp);</span><br><span class="line">	linktbl-&gt;links = CALLOC(linktbl-&gt;num, <span class="keyword">sizeof</span>(Link *));</span><br><span class="line">	<span class="comment">//遍历link获取所需内容,并返回</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linktbl-&gt;num; i++) &#123;</span><br><span class="line">		linktbl-&gt;links[i] = CALLOC(<span class="number">1</span>, <span class="keyword">sizeof</span>(Link));</span><br><span class="line">		fread(linktbl-&gt;links[i]-&gt;linkname, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), MAX_FILENAME_LEN, fp);</span><br><span class="line">		fread(linktbl-&gt;links[i]-&gt;f_url, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), MAX_PATH_LEN, fp);</span><br><span class="line">		fread(&amp;linktbl-&gt;links[i]-&gt;type, <span class="keyword">sizeof</span>(LinkType), <span class="number">1</span>, fp);</span><br><span class="line">		fread(&amp;linktbl-&gt;links[i]-&gt;content_length, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>), <span class="number">1</span>, fp);</span><br><span class="line">		fread(&amp;linktbl-&gt;links[i]-&gt;time, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fp);</span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			<span class="comment">/* reached EOF */</span></span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">					<span class="string">&quot;LinkTable_disk_open(): reached EOF!\n&quot;</span>);</span><br><span class="line">			LinkTable_free(linktbl);</span><br><span class="line">			LinkTable_disk_delete(dirn);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;LinkTable_disk_open(): encountered ferror!\n&quot;</span>);</span><br><span class="line">			LinkTable_free(linktbl);</span><br><span class="line">			LinkTable_disk_delete(dirn);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fclose(fp)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">				<span class="string">&quot;LinkTable_disk_open(): cannot close the file pointer, %s\n&quot;</span>,</span><br><span class="line">				strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> linktbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>network.c 和network.h,获取http文件服务器内容,详情请参考<code>https://curl.haxx.se/libcurl/c/threaded-ssl.html</code>这位作者也是参考此源码完成.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkSystem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="comment">/* ------- Global related ----------*/</span></span><br><span class="line">	<span class="comment">//初始化http的curl,如果非CURL_GLOBAL_ALL则初始化失败退出</span></span><br><span class="line">	<span class="keyword">if</span> (curl_global_init(CURL_GLOBAL_ALL)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_global_init() failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -------- Share related ----------*/</span></span><br><span class="line">	<span class="comment">//返回curl句柄,获取相应我curl</span></span><br><span class="line">	CURL_SHARE = curl_share_init();</span><br><span class="line">	<span class="keyword">if</span> (!(CURL_SHARE)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_share_init() failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给目标穿参</span></span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_SHARE, CURL_LOCK_DATA_SSL_SESSION);</span><br><span class="line">	<span class="comment">//thread的初始化</span></span><br><span class="line">	<span class="keyword">if</span> (pthread_mutex_init(&amp;curl_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_lock initialisation failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_LOCKFUNC, curl_callback_lock);</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_UNLOCKFUNC, curl_callback_unlock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理多个curl</span></span><br><span class="line">	<span class="comment">/* ------------- Multi related -----------*/</span></span><br><span class="line">	curl_multi = curl_multi_init();</span><br><span class="line">	<span class="keyword">if</span> (!curl_multi) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_multi_init() failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line">	curl_multi_setopt(curl_multi, CURLMOPT_MAX_TOTAL_CONNECTIONS,</span><br><span class="line">					CONFIG.max_conns);</span><br><span class="line">	curl_multi_setopt(curl_multi, CURLMOPT_MAX_HOST_CONNECTIONS,</span><br><span class="line">					CONFIG.max_conns);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ------------ Initialise locks ---------*/</span></span><br><span class="line">	<span class="keyword">if</span> (pthread_mutex_init(&amp;transfer_lock, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">				<span class="string">&quot;network_init(): transfer_lock initialisation failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line">	crypto_lock_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fuse_local.c和fuse_local.h,搭建本地fuse文件系统,本文上半部分已经详细介绍原理.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_readdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *buf, <span class="keyword">fuse_fill_dir_t</span> dir_add,<span class="keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(<span class="keyword">void</span>) offset;</span><br><span class="line">	(<span class="keyword">void</span>) fi;</span><br><span class="line"></span><br><span class="line">	Link *link;</span><br><span class="line">	LinkTable *linktbl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">		linktbl = ROOT_LINK_TBL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		linktbl = path_to_Link_LinkTable_new(path);<span class="comment">//如果非根目录,则从link中重新拉去当前目录所有文件夹,和文件从而实现文件夹的存储.缺点是要试试刷新多文件会有较高延迟</span></span><br><span class="line">		<span class="keyword">if</span>(!linktbl) &#123;</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start adding the links */</span></span><br><span class="line">	dir_add(buf, <span class="string">&quot;.&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	dir_add(buf, <span class="string">&quot;..&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; linktbl-&gt;num; i++) &#123;</span><br><span class="line">		link = linktbl-&gt;links[i];</span><br><span class="line">		<span class="keyword">if</span> (link-&gt;type != LINK_INVALID) &#123;</span><br><span class="line">			dir_add(buf, link-&gt;linkname, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>总结</strong>:通过http(curl库),和fuse(fuse库).点击当前文件夹就会从http拉去当前文件夹所有内容,从而实现了把http文件系统服务器挂在至本机磁盘中.makefile直接使用make生成可执行文件httpdirfs,然后调用如下命令即可使用<blockquote>
<p>./httpdirfs -f –cache $URL $MOUNT_POINT</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux利用fuse实现文件系统</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【windows技术】利用go搭建纯文件http服务器，并生成dll</title>
    <url>/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="利用go搭建纯文件http服务"><a href="#利用go搭建纯文件http服务" class="headerlink" title="利用go搭建纯文件http服务"></a>利用go搭建纯文件http服务</h1><p><em><strong>在windows下使用go搭建纯文件服务器，并生成标准dll导出文件。</strong></em></p>
<span id="more"></span>

<h2 id="go实现HTTP文件服务器"><a href="#go实现HTTP文件服务器" class="headerlink" title="go实现HTTP文件服务器"></a>go实现HTTP文件服务器</h2><ol>
<li><p>利用<code>net/http</code>库文件创建<code>http</code>服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, port <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">pathlist := GetLogicalDrives()<span class="comment">//获取windows卷标</span></span><br><span class="line">mux.Handle(<span class="string">&quot;/&quot;</span>, http.StripPrefix(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;/&quot;</span>))))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> pathlist &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;path:&quot;</span>, v)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	Path := <span class="string">&quot;/&quot;</span> + v + (<span class="string">&quot;/&quot;</span>)</span><br><span class="line">	Dir := v + <span class="string">&quot;:&quot;</span></span><br><span class="line">	mux.Handle(strings.ToLower(Path), http.StripPrefix(strings.ToLower(Path), http.FileServer(http.Dir(strings.ToLower(Dir)))))</span><br><span class="line">	fmt.Println(<span class="string">&quot;path:&quot;</span>, Path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dir:&quot;</span>, Dir)</span><br><span class="line">&#125;</span><br><span class="line">service := <span class="keyword">string</span>(<span class="string">&quot;:&quot;</span>) + strconv.FormatInt(<span class="keyword">int64</span>(port), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span> serve(service, mux, stop)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用<code>syscall</code>标准系统库，遍历<code>windows</code>的磁盘卷标</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">GetLogicalDrives</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)<span class="comment">//windows系统标准库</span></span><br><span class="line">GetLogicalDrives := kernel32.MustFindProc(<span class="string">&quot;GetLogicalDrives&quot;</span>)</span><br><span class="line">n, _, _ := GetLogicalDrives.Call()</span><br><span class="line">s := FormatInt(<span class="keyword">int64</span>(n), <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> drives_all = []<span class="keyword">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;U&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;Z&quot;</span>&#125;</span><br><span class="line">temp := drives_all[<span class="number">0</span>:<span class="built_in">len</span>(s)]</span><br><span class="line"><span class="keyword">var</span> d []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">	<span class="keyword">if</span> v == <span class="number">49</span> &#123;</span><br><span class="line">		l := <span class="built_in">len</span>(s) - i - <span class="number">1</span></span><br><span class="line">		d = <span class="built_in">append</span>(d, temp[l])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">	<span class="comment">//	 drives = append(drives[i:], append([]string&#123;v&#125;, drives[:i]...)...)</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用<code>http</code>的server的停止机制，关闭http服务器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="keyword">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">s := http.Server&#123;</span><br><span class="line">	Addr:    addr,</span><br><span class="line">	Handler: handler,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-stop <span class="comment">// wait for stop signal</span></span><br><span class="line">	s.Shutdown(context.Background()) <span class="comment">//停止服务器</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="go导出dll标准导出文件"><a href="#go导出dll标准导出文件" class="headerlink" title="go导出dll标准导出文件"></a>go导出dll标准导出文件</h2><ol>
<li><p>进入官网<code>https://gcc.gnu.org/install/binaries.html</code>，选择Microsoft -&gt; mingw64。安装MinGW-w64。</p>
<p><img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/1.png" alt="图1"></p>
<p><img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/2.png" alt="图2"></p>
<p><img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/3.png" alt="图3"></p>
</li>
</ol>
<ol start="2">
<li><p>选择安装版本，选择32位或者64位的版本进行安装，如果你生成dll想为32为位的时候就要选择32位就是<code>i686</code></p>
<p> <img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/4.png" alt="图4"></p>
</li>
<li><p>把<code>mingw32\bin</code>加入到环境变量中,<code>我的电脑-&gt;高级系统设置-&gt;环境变量</code>,在命令刚中输入<code>gcc -v</code>有版本信息则调试成功.</p>
<p> <img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/5.png" alt="图5"></p>
</li>
<li><p>在go程序中在需要导出函数的头文件加入<code>//export </code>如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//export stop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Stop Http!&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(Stopch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行下命令就OK,或者参考下我的博客中的<code>export.dat</code>脚本</p>
</li>
</ol>
<blockquote>
<p>go build -ldflags “-s -w” -o main.dll -buildmode=c-shared main.go</p>
</blockquote>
<ol start="6">
<li>在导出的<code>.h</code>文件中我们需要把三行注释</li>
</ol>
<blockquote>
<p>typedef <strong>SIZE_TYPE</strong> GoUintptr;</p>
</blockquote>
<blockquote>
<p>typedef float _Complex GoComplex64;</p>
</blockquote>
<blockquote>
<p>typedef double _Complex GoComplex128;</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>windows技术</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用QT的clipboard库监听和设置剪切板</title>
    <url>/2021/06/02/UOS%E5%88%A9%E7%94%A8QT%E7%9B%91%E5%90%AC%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="利用QT的clipboard库监听和设置剪切板"><a href="#利用QT的clipboard库监听和设置剪切板" class="headerlink" title="利用QT的clipboard库监听和设置剪切板"></a>利用QT的clipboard库监听和设置剪切板</h1><p><em><strong>使用QT的Clipboard库，监听和设置uos剪切板变化。经过dbus接口，把uos的剪切板暴露出来，从而进行设置和监听</strong></em></p>
<span id="more"></span>

<h2 id="dbus的创建"><a href="#dbus的创建" class="headerlink" title="dbus的创建"></a>dbus的创建</h2><ol>
<li>在C++头文件定义<code>Q_SLOTS</code>,和<code>Q_SIGNALS</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clipboard</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="built_in">Q_CLASSINFO</span>(<span class="string">&quot;D-Bus Interface&quot;</span>, <span class="string">&quot;com.deepin.ListenClipboard&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Clipboard</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Q_SLOTS:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDataToCB</span><span class="params">(<span class="keyword">const</span> QString &amp;clipboardData, <span class="keyword">const</span> <span class="keyword">int</span> nType)</span></span>;</span><br><span class="line"></span><br><span class="line">Q_SIGNALS:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClipboardChanged</span><span class="params">(<span class="keyword">const</span> QString &amp;pathlist, <span class="keyword">const</span> <span class="keyword">int</span> nType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建导出dbus接口的xml文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">node</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//freedesktop//DTD D-BUS Object Introspection 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span> <span class="attr">name</span>=<span class="string">&quot;com.deepin.ListenClipboard&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">signal</span> <span class="attr">name</span>=<span class="string">&quot;ClipboardChanged&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">type</span>=<span class="string">&quot;s&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;out&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;nType&quot;</span> <span class="attr">type</span>=<span class="string">&quot;i&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;out&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">signal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method</span> <span class="attr">name</span>=<span class="string">&quot;SetClipboardData&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">type</span>=<span class="string">&quot;s&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;in&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;nType&quot;</span> <span class="attr">type</span>=<span class="string">&quot;i&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;in&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用工具生成适配器类</li>
</ol>
<p><code>qdbusxml2cpp com.deepin.ListenClipboard.xml -i  com.deepin.ListenClipboard.xml -a widgetadaptor</code></p>
<ol start="4">
<li> 安装适配器将Widget类中的方法导出<code>DemoAdaptor adaptor(&amp;w);</code></li>
</ol>
<h2 id="剪切板监听"><a href="#剪切板监听" class="headerlink" title="剪切板监听"></a>剪切板监听</h2><ol>
<li>调用<code>connect</code>，把自己的<code>func</code>和<code>cilpboard</code>变化连接一起 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clipboard::CheckDataToCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">connect</span>(m_clipBoard, &amp;QClipboard::dataChanged, <span class="keyword">this</span>, &amp;Clipboard::ListenDataToCB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取文件图片和文字</li>
</ol>
<ul>
<li><p>图片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage img = qvariant_cast&lt;QImage&gt;(strMimeData-&gt;<span class="built_in">imageData</span>());</span><br><span class="line">QByteArray imageArray;</span><br><span class="line">QBuffer buffer;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">img.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;PNG&quot;</span>);</span><br><span class="line">imageArray.<span class="built_in">append</span>(buffer.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure></li>
<li><p>文字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString strText = strMimeData-&gt;<span class="built_in">text</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;clipboard text received:&quot;</span> &lt;&lt; strText;</span><br></pre></td></tr></table></figure></li>
<li><p>文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString strFileList;</span><br><span class="line">QList&lt;QUrl&gt; cbUrls = strMimeData-&gt;<span class="built_in">urls</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cbUrls.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    QString strFile = cbUrls.<span class="built_in">at</span>(i).<span class="built_in">toLocalFile</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFusePath</span>(strFile) || <span class="number">0</span> == strFile.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    strFileList += strFile + <span class="string">&quot;\n&amp;t&quot;</span>; <span class="comment">// windows约定文件路径分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;clipboard file received:&quot;</span> &lt;&lt; strFileList;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>发送数据至<code>Q_SIGNALS</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">emit <span class="title">ClipboardChanged</span><span class="params">(strClipboardData,<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(nType))</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="剪贴板设置"><a href="#剪贴板设置" class="headerlink" title="剪贴板设置"></a>剪贴板设置</h2></li>
<li><p>使用dbus绑定接口<code>SetDataToCB</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMetaObject::<span class="built_in">invokeMethod</span>(<span class="built_in">parent</span>(), <span class="string">&quot;SetDataToCB&quot;</span>, <span class="built_in">Q_ARG</span>(QString, path),<span class="built_in">Q_ARG</span>(<span class="keyword">const</span> <span class="keyword">int</span>,nType));</span><br></pre></td></tr></table></figure></li>
<li><p>设置文件图片和文字</p>
</li>
</ol>
<ul>
<li><p>图片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage img;</span><br><span class="line">QByteArray arr_base64 = clipboardData.<span class="built_in">toLatin1</span>();</span><br><span class="line">img.<span class="built_in">loadFromData</span>(QByteArray::<span class="built_in">fromBase64</span>(arr_base64));</span><br><span class="line">m_clipBoard-&gt;<span class="built_in">setImage</span>(img);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set clipboard data as Image&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_clipBoard-&gt;<span class="built_in">setText</span>(clipboardData);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set clipboard data as text:&quot;</span> &lt;&lt; clipboardData;</span><br></pre></td></tr></table></figure></li>
<li><p>文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString CopiedFile;</span><br><span class="line">QString UrlList;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set clipboard data as file:&quot;</span> &lt;&lt; clipboardData;</span><br><span class="line">QStringList clipboardList = clipboardData.<span class="built_in">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (QString path : clipboardList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        CopiedFile = CopiedFile + <span class="string">&quot;copy\nfile://&quot;</span> + path;</span><br><span class="line">        UrlList = UrlList + <span class="string">&quot;file://&quot;</span> + path + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CopiedFile.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;clipboard path is empty&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QMimeData *newMimeData = <span class="keyword">new</span> <span class="built_in">QMimeData</span>();</span><br><span class="line">newMimeData-&gt;<span class="built_in">setData</span>(<span class="string">&quot;x-special/gnome-copied-files&quot;</span>,</span><br><span class="line">                     <span class="built_in">QByteArray</span>(CopiedFile.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">newMimeData-&gt;<span class="built_in">setData</span>(<span class="string">&quot;text/uri-list&quot;</span>, <span class="built_in">QByteArray</span>(UrlList.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">m_clipBoard-&gt;<span class="built_in">clear</span>();</span><br><span class="line">m_clipBoard-&gt;<span class="built_in">setMimeData</span>(newMimeData);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决UOS部分问题</title>
    <url>/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决UOS部分问题"><a href="#解决UOS部分问题" class="headerlink" title="解决UOS部分问题"></a>解决UOS部分问题</h1><ul>
<li>修改配置文件，实现UOS文管不显示已挂载磁盘。</li>
<li>解决扩展屏时,dock栏来回跳转</li>
</ul>
<span id="more"></span>
<h2 id="1-UOS挂载磁盘不显示"><a href="#1-UOS挂载磁盘不显示" class="headerlink" title="1. UOS挂载磁盘不显示"></a>1. UOS挂载磁盘不显示</h2><p>问题描述：</p>
<p>多个磁盘在文管显示，其实都是零碎的挂载没什么用，现在要想开机把他隐藏。<br><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/1.png" alt="图1"></p>
<p>解决方案1：</p>
<ul>
<li><p>可以在/lib/udev/rules.d/80-udisks2.rules 里面加入<code>ENV&#123;ID_fS_TYPE&#125;==&quot;squashfs&quot; ENV&#123;UDISKS_IGNORE&#125;=&quot;1&quot;</code></p>
<p><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/2.png" alt="图2"></p>
</li>
<li><p>/etc/udev/rules.d下面如果有80-udisks2.rules这个文件，刚刚的修改没有意义，大家把这个文件改个名字即可：/etc/udev/rules.d/80-udisks2-install.rules。这是老版本bug</p>
<p><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/3.png" alt="图3"></p>
</li>
</ul>
<p>解决方案2：</p>
<ul>
<li>我遇见的是fusemount挂载，想在文管隐藏，当我挂载到<code>/tmp</code>目录下任何一个文件夹下文管就不显示了。</li>
</ul>
<p><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/4.png" alt="图4"></p>
<h2 id="2-扩展屏幕dock来回跳转"><a href="#2-扩展屏幕dock来回跳转" class="headerlink" title="2. 扩展屏幕dock来回跳转"></a>2. 扩展屏幕dock来回跳转</h2><p>解决方案:</p>
<blockquote>
<p>gsettings set com.deepin.dde.dock.mainwindow only-show-primary true</p>
</blockquote>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】vscode上go的自动补全和跳转</title>
    <url>/2021/04/27/vscode%E4%B8%ADgo/</url>
    <content><![CDATA[<h1 id="vscode上go自动补全问题和跳转问题"><a href="#vscode上go自动补全问题和跳转问题" class="headerlink" title="vscode上go自动补全问题和跳转问题"></a>vscode上go自动补全问题和跳转问题</h1><p><em><strong>在UOS环境下用vscode，不能跳转和自动补全。</strong></em></p>
<span id="more"></span>
<h2 id="ctrl不能跳转"><a href="#ctrl不能跳转" class="headerlink" title="ctrl不能跳转"></a>ctrl不能跳转</h2><p>解决：</p>
<ul>
<li>settings-&gt;搜索 use language server-&gt;Go: Use Language Server 改为非选中状态,就可以跳转了,这里是重点,重点.必须的要更改。</li>
<li>设置搜索Docs Tool，把 Docs Tool改成gogetdoc或者guru试试，我的用guru就可以。</li>
</ul>
<h2 id="自动补全失效"><a href="#自动补全失效" class="headerlink" title="自动补全失效"></a>自动补全失效</h2><p>解决：<br>在升级到 1.11后， go加入了go module这一特性， 支持相对路径的导入包，这样在$GOPATH之外的地方也可以进行项目开发。</p>
<ol>
<li>但是vscode中很多插件只能工作在 $GOPATH下， 其中最重要的代码智能提示也是如此代码提示主要由 github.com/mdemsky/gocode 这个模块负责， 为了支持go module， 要使用新的gocode模块，项目地址为 github.com/stamblerre/gocode， 为了更新插件</li>
</ol>
<p>将$GOPATH/bin 中的 gocode 可执行文件删掉</p>
<ol start="2">
<li><p>go get -u -v github.com/stamblerre/gocode 获取包， 这里是不能安装的，有冲突</p>
</li>
<li><p>去到 $GOPATH/src/golang.org/x 这个目录下， 删除tools这个包，它和新版的 gocode不兼容，不要试图 git pull获取最新版，这个是被墙了的</p>
</li>
<li><p>从 <a href="https://github.com/golang/tools">https://github.com/golang/tools</a> 下载最新的tools包，clone很慢就直接下载 zip 文件， 解压到刚才原来的位置。</p>
</li>
<li><p>编译安装 stamblerre/gocode， go build -o $GOPATH/bin/gocode-gomod github.com/stamblerre/gocode或者直接到$GOPATH/src/github.com/stamblerre/gocode目录下执行go build</p>
</li>
</ol>
<p>到此， Vscode智能提示就可以正常工作了</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】谈谈《博弈论诡计》</title>
    <url>/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>在一个咖啡屋偶然接触到这本书，当时旁边我翻遍了隔壁书架，一群要么是《骆驼祥子》，《呐喊》，《酒馆》这种上世纪的书，或是再给我整点余秋雨的风风雨雨，或者是再搞点三毛的恩恩爱爱，想找两本王朔的或者余华硬一点的却翻不到，碰巧遇到了，博弈论。现在想起，可能是《博弈论》前两的囚徒困境吸引住了我吧。现在距看完这本书两个月了，许多片段还能历历在目。</strong></em></p>
<span id="more"></span>

<h2 id="对人的博弈"><a href="#对人的博弈" class="headerlink" title="对人的博弈"></a>对人的博弈</h2><p>我觉得如果是正经人对完这本书，应该对一点人情世故有所提升。我只能讲一下，我自己看完的对其浅薄的理解。每个人和其他人交往是时候都是在博弈，可能你自己没有注意到，但是和他人的博弈都是在井然有序的发生，默认的处理的方法就是经验论，参照别人处理的方式。这种方法总不能说是错的，但回头想想这可能不是最优解，每个人性格，遇到的矛盾总是不同而已的，一招鲜吃遍天，不太适用。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/1.jpeg" alt="图1"></p>
<p><code>举个栗子</code>：当你公司同事想去聚餐，想把你拉过去，但是你刚进公司，对公司同事不熟悉，这时候你就要考虑拒绝他还是答应他呢，我们画个表格。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/15.png" alt="图15"></p>
<p>表格上很清楚明了，如果你觉得自身的舒适度比同事好感度重要的话，合理的拒绝总是利大于弊的，如果是刚来公司，想在新公司发展的话，还是多多的参加聚餐与同事熟络。可能你觉得这个栗子比较简单，生活中的经验论完全就可以解决这个问题，但是事实上许多复杂的东西，就是需要这种逻辑，特别的当你的对手是一个相当成熟的职场上<code>高手</code>的时候，他的每一步都在深思熟虑，都在找一个最优解。历史上往往很离谱的事情，把我们代入过去一步一步分析，那个离谱结果可能就是就是最优解。</p>
<h2 id="对社会博弈理解"><a href="#对社会博弈理解" class="headerlink" title="对社会博弈理解"></a>对社会博弈理解</h2><p>社会上博弈从博弈论创始到现在，开始是冯·诺依曼证明了博弈论的基本原理，纳什有过完善，再～～～～～～～～发展，我就不记人名了，原谅我的差记性。大概是从提出的了博弈论，然后提出了博弈论的囚徒困境的局限性，再而破解了囚徒困境，提出了合作博弈理论，大概是这个历程。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/2.jpeg" alt="图2"></p>
<p><code>举个栗子</code>：知乎上有个问题说的很好，核武器的六层猜疑链核威慑里的六层猜疑链<br>什么叫核威慑？很多人理解的核威慑，就是你敢发射核弹搞死我，我就敢发射核弹搞死你。在那个曾经只有美苏拥有核武器的年代，核威慑确实是这样的。但如今不是了。冷战末期时，美国拥有核弹头31255枚，苏联那边也差不多，每年的维护保养费用都是一个天文数字。那个年代，美苏两国确实是奔着直接搞死对面的心态去的，而且要有能搞死对面很多遍的能力才放心。1991年，美苏两国达成协议，削减各自的核武器，直接把人类接近80%的核武器化为乌有。但即便如此，美苏两国依然各自拥有近7000枚核武器，依然可以把对方搞死很多遍。目前全人类总共有15000多枚核弹头，基本都在美国和俄罗斯那里。而中国的核武器一直数量很少，只有美苏两国的零头，大概几百枚的样子。如此之少的核武器，怎么和美俄抗衡？</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/3.jpeg" alt="图3"></p>
<p>以前的中国穷，造不起，甚至维护不起核武器，这可以理解。但今天的中国不穷了啊，为什么不造几万枚核武器撑场面？因为完全没有必几百枚核武器，已经够用了。够用的原因，不是因为几百枚核武器真的够用，而是因为美国和俄罗斯的核武器够用。美国和俄罗斯的核武器，就是中国的核武器。核武器+洲际导弹的组合，让核威慑产生了极其复杂的变化。如果美国决定拿出3000枚核武器，先发制人，在中国没有反应过来之前就对中国进行地毯式核轰炸，把中国从地球上彻底的抹去。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/4.jpeg" alt="图4"></p>
<p>那美国担心的是中国的核反制么？确实会担心，因为美国的反导系统不可能拦截中国发射的所有核武器，肯定有不少核弹头直接落在美国的大城市里。但这并不是美国最害怕的事情。美国最害怕的，是引发全球所有核国家的猜疑。首先，发动核攻击之前是要绝对保密的，绝对不可能对世界宣布的，更不可能挨个和盟友甚至敌国进行解释。这道理很好理解。假设你和对手都有枪，互相指着对手的头，谁都不敢开枪，这个时候如果对手告诉你，他准备开枪了，请问你会怎么做？</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/5.jpeg" alt="图5"></p>
<p>如果核攻击真的发动，那一定是毫无征兆的。<br>假如美国3000枚核弹头铺天盖地的向亚洲飞过来，在洲际导弹飞行的这十几分钟里，各核国家会想很多很多事情。</p>
<ul>
<li>第一层猜疑链：比如说俄罗斯，他首先会想一件事，这么多导弹到底是来炸谁的，是炸中国？还是炸俄罗斯？根据雷达测定，目前的飞行轨迹全部指向中国，看起来好像是炸中国的。但洲际导弹都是可以变轨的，这些弹头会不会在落地前分出一半，突然变轨来炸俄罗斯？等它变轨后，俄罗斯只有三分钟时间了，压根都没时间反应。如果等俄罗斯被炸了再反制，是不是太晚了？要不要提前发射核武器，先把美国给炸了，以防万一。这个问题，不仅俄罗斯会想，英国和法国也会想。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/6.jpeg" alt="图6"></p>
<ul>
<li>第二层猜疑链：除了害怕洲际导弹突然变轨之外，俄罗斯还会想一个问题。美国哪来的胆子突然炸中国的，他炸中国的目的是什么，他为什么敢炸中国。如果美国冒着本国被核弹攻击的风险，对中国发动核袭击，那为什么不顺便把俄罗斯一起给炸了，反正承担的风险是差不多的。所以，俄罗斯人会预估美国肯定会对俄罗斯发动核攻击。不管第一波核导弹是炸中国还是炸俄罗斯的，最后都一定会炸俄罗斯。既然如此，那俄罗斯索性就先动手吧。同样，这个问题，不仅俄罗斯会想，英国和法国也会想。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/7.jpeg" alt="图7"></p>
<ul>
<li>第三层猜疑链：更可怕的是，美国担心的绝不仅仅是俄罗斯的不信任。假设俄罗斯的领导人，有超强的定力，对美国有超强的信任，对人类有超强的慈悲之心，相信美国是只炸中国的，冒着俄罗斯人全部被屠灭的风险，最后没有下令发射核弹。俄罗斯还要担心一个问题，中国在对美国发动核反制的同时，会不会顺便给俄罗斯、英国、法国丢一波核弹。反正那个时候中国已经没了，名声这东西要来干嘛呢，大家一起死好了。这不是说中国一定会这么做，只要可能这么做就很可怕了。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/8.jpeg" alt="图8"></p>
<ul>
<li>第四层猜疑链：如果中国遭受美国核攻击后，可能会攻击全球核大国，那么英国法国应该如何自保？假如俄罗斯被炸了，哪怕只有几个主要大城市被炸了，国力都会严重削弱，从而彻底衰退，甚至可能会灭国。那么，俄罗斯会不会直接炸平全球，来确保俄罗斯的安全，或者拉全球给俄罗斯陪葬？如果英国和法国假定俄罗斯会这么做，那么为了英国和法国的国家利益最大化。从最理智的角度，英国和法国，应该立即发射所有的核弹，拉全球陪葬。偏偏一国领导人，一般来说都是相当理智的。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/12.jpeg" alt="图9"></p>
<ul>
<li>第五层猜疑链：当美国对中国发射核弹后，如果美国假定中国会核反制其他核大国，然后假定其他核大国为了自身利益最大化，都会直接把核弹头丢在美国头上，那美国会怎么应对这一情况？因为这个概率不仅有，而且还很高。作为美国，如果想要让本国利益最大化，在核攻击中国的同时，就应该同时核攻击俄罗斯、英国和法国等任何有能力对美国发动核攻击的国家。这才是美国最理性的选择。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/13.jpeg" alt="图10"></p>
<ul>
<li>第六层猜疑链：因为俄罗斯、英国和法国，都知道美国肯定会受困在第五层猜疑链，对本国发动核攻击的概率非常之大，自己无论怎么做都无法安抚美国。毕竟此时的美国已经疯了，如果不疯是无论如何都不敢发动核战争的。英法俄估计美国肯定会估计英法俄会估计美国会炸掉英法俄。所以英法俄无论如何都无法获得安全感。既然美国肯定会受困在猜疑链，肯定会对所有核国家发动打击，那么自己肯定就是个死。那，自己索性就拉全世界一起陪葬吧，说不定最后的情况还好一点。因此，在看到美国核弹头铺天盖地射向中国的一瞬间，俄罗斯、英国和法国，就会同时启动自己国家的核武库，向全世界所有国家发射核弹。你是真心实意的想炸中国？巧了，我怕你炸的不干净，或者导弹中途变向来炸我，我也帮你炸一遍中国吧，另外把你美国也全给炸了。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/11.jpeg" alt="图11"></p>
<p>这六层猜疑链，基本没有国家能熬过去。而且即便有个把国家的领导人熬过去了，也没用，需要所有核国家的领导人全部熬过去，拿命去相信彼此，才算破除猜疑链。上面的全是转自知乎，我觉得是个经典的博弈所以引用一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当我们不知道对方底牌时，保持沉默是一个不错的办法。</li>
<li>从长远来看，赌博是一个注定会输的游戏。</li>
<li>如果一开始就让人觉得你多么了不起，对你给予了种种厚望，可你随后的表现让人一次又一次的失望，结果你只会被人越来越看不起。这种反差效应值得人们借鉴。别人对你的期望值越高，越容易看出你的平庸，发现你的错误;相反，如果别人本来对你并不抱有厚望，你的成绩就回容易被人发现，甚至让人吃惊。</li>
<li>一个人的信息量是很有限的，要通过群体拓展思路，打开局面，才能在残酷的市场竞争中站稳脚跟。</li>
<li>“当你自估的成功概率达到%40~%70，你就该去这件事了。也许你会失败，但拖延或等待的代价往往更大。”</li>
<li>在幸福博弈时，不要拿自己的不幸和别人幸福的一面去比。决定你快乐或不快乐的，不是别人，是你自己。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/16.png" alt="图16"></p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】systemctl和service启动服务</title>
    <url>/2021/04/25/systemctl%E5%92%8Cservice/</url>
    <content><![CDATA[<h1 id="Linux开启自启服务器"><a href="#Linux开启自启服务器" class="headerlink" title="Linux开启自启服务器"></a>Linux开启自启服务器</h1><p><em><strong>网上很多介绍systemctl和service的区别和使用，我觉得都没有说到点子上，本文介绍这两个自启动命令，并且加自己经常使用具体方法。</strong></em></p>
<span id="more"></span>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><ol>
<li><p>背景说明</p>
<blockquote>
<p>systemd，当系统启动之后systemd就会成功系统的第一个进程，而我们这个systemctl命令就是systemd命令中最重要的命令之一，用于管理系统。</p>
</blockquote>
<blockquote>
<p>systemctl命令在centos6及以下版本是不支持的，调用这个命令会报<code>命令未找到</code> or <code>command not found</code>错误,但是在7以上Linux为了提高系统的启动速度，尽可能的增加多个进程同时启动，所以就支持了systemd，也就是systemctl命令。</p>
</blockquote>
</li>
<li><p>调用方法</p>
<table>
<thead>
<tr>
<th align="left">systemctl 命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">systemctl stop</td>
<td align="left">停止</td>
</tr>
<tr>
<td align="left">systemctl start</td>
<td align="left">开始</td>
</tr>
<tr>
<td align="left">systemctl status</td>
<td align="left">查看状态</td>
</tr>
<tr>
<td align="left">systemctl mark</td>
<td align="left">注销</td>
</tr>
<tr>
<td align="left">systemctl suspend</td>
<td align="left">进入睡眠</td>
</tr>
<tr>
<td align="left">systemctl hibermate</td>
<td align="left">进入休眠</td>
</tr>
<tr>
<td align="left">systemctl get-default</td>
<td align="left">获得当前运行级别</td>
</tr>
</tbody></table>
</li>
<li><p>具体调用逻辑</p>
<blockquote>
<p>关键词daemon：后台服务进程，常驻。</p>
</blockquote>
<p> 文件保存路径主要是在以下三个路径，我自己写的service文件通常会用脚本，拷贝到下面三个路径中。</p>
<ul>
<li>/usr/lib/systemd/system</li>
<li>/run/systemd/system</li>
<li>/etc/systemd/system</li>
</ul>
<p> unit文件分很多种，我主要讲一下service文件和Target文件，这两个文件在写linux应用的时候用的比较多一点。</p>
<ol>
<li><p>service:文件扩展名为.service，用于定义系统服务，文件内容类似于desktop文件。</p>
<p> [unit]段常用的选项</p>
<ul>
<li>Description：描述信息，意义性描述</li>
<li>After：定义unit的启动顺序，晚于某服务启动</li>
<li>Requies：依赖其他的units，当依赖的服务没启动，是不能启动此服务的，强依赖</li>
<li>Waints：和上面一样，弱依赖</li>
<li>Conficts：定义units冲突关系（不太明白）</li>
</ul>
<p> [Service]段常用选项</p>
<ul>
<li><p>Type：用于定义影响ExecStart和相关参数功能unit进程启动类型</p>
<ol>
<li>simple:默认值，这个daemon主要由execstart后面所写的字符串来启动，启动后常驻内存。</li>
<li>forking:由 ExecStart 启动的程序通过 spawns 延伸出其他子程序来作为此 daemon 的主要服务。原生的父程序在启动结束后就会终止运行，ps：类似于管道启动</li>
<li>oneshot:与simple类似的启动方式类似，但是工作完就结束，不常驻内存</li>
<li>dbus:与simple类似的启动方式类似，但要设置DbusName=XX，daemon程序才会运行。</li>
<li>notify:暂时不了解</li>
<li>idle:与simple类似，要执行这个daemon 必须要所有的工作都顺利执行完毕后才会执行。这类的daemon 通常是开机到最后才执行即可的服务</li>
</ol>
</li>
<li><p>EnvironmentFile：环境配置文件</p>
</li>
<li><p>ExecStart：启动脚本或者命令进程</p>
</li>
<li><p>ExecStop：停止脚本或者命令进程</p>
</li>
</ul>
<p> [install]段常用选项</p>
<ul>
<li>Alias：暂时不了解</li>
<li>RequiredBy：被哪些units所依赖，强</li>
<li>WantedBy：如上，弱</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>2. Target：文件扩展为.target，用于模拟实现“运行级别”。


举个实际性的例子，如果我完成了一个程序的编写或者脚本的编写，想让他开机启动并且常驻的话，我就可以自己写一个servcie文件，放入上文中三条路径中，类似下面这个文件。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;test</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;home&#x2F;mecry&#x2F;DemonShell</span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

ExecStart就是我在电脑中目标脚本，脚本中可以写一些监视开机启动的命令，输出到指定文件夹下，比如我监听笔记本闭合事件，开关机时间等，具体日志输出就在/home中的listen.txt文件下。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 | evtest &gt;&gt;/home/listen.txt</span><br></pre></td></tr></table></figure>
</code></pre>
<p><strong>注意：脚本启动都是已root权限启动，方便调试。非root权限无法启动service服务</strong></p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><ol>
<li><p>背景说明</p>
<blockquote>
<p>service本质为进程，是linux最早控制服务的一种手段，并不是所有linux都有这个命令，主要是在redhat，fedora，mandriva，centos中 ，这个命令的可执行程序在/sbin下（一般进程都是在/usr/bin下）</p>
</blockquote>
</li>
<li><p>调用方法</p>
<blockquote>
<p>其实没什么调用方法，主要是看你service下的逻辑支持是什么实现，就可以怎么实现。<br> 比如<code>service dbus start</code>，其实调用dbus这个服务文件中start的函数实现。</p>
</blockquote>
</li>
<li><p>具体实现</p>
<p> 看个栗子，比如我本机的dbus服务,文件存放都存放在<code>/etc/init.d/</code>目录下。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          dbus</span></span><br><span class="line"><span class="comment"># Required-Start:    $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Required-Stop:     $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:</span></span><br><span class="line"><span class="comment"># Short-Description: D-Bus systemwide message bus</span></span><br><span class="line"><span class="comment"># Description:       D-Bus is a simple interprocess messaging system, used</span></span><br><span class="line"><span class="comment">#                    for sending messages between applications.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Debian init.d script for D-BUS</span></span><br><span class="line"><span class="comment"># Copyright © 2003 Colin Walters &lt;walters@debian.org&gt;</span></span><br><span class="line"><span class="comment"># Copyright © 2005 Sjoerd Simons &lt;sjoerd@debian.org&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">DAEMON=/usr/bin/dbus-daemon</span><br><span class="line">UUIDGEN=/usr/bin/dbus-uuidgen</span><br><span class="line">UUIDGEN_OPTS=--ensure</span><br><span class="line">NAME=dbus</span><br><span class="line">DAEMONUSER=messagebus</span><br><span class="line">PIDDIR=/var/run/dbus</span><br><span class="line">PIDFILE=<span class="variable">$PIDDIR</span>/pid</span><br><span class="line">DESC=<span class="string">&quot;system message bus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$DAEMON</span> || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source defaults file; edit that file to configure this script.</span></span><br><span class="line">PARAMS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -e /etc/default/dbus ]; <span class="keyword">then</span></span><br><span class="line">. /etc/default/dbus</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">create_machineid</span></span>() &#123;</span><br><span class="line"><span class="comment"># Create machine-id file</span></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="variable">$UUIDGEN</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$UUIDGEN</span> <span class="variable">$UUIDGEN_OPTS</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_it_up()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$PIDDIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir -p <span class="variable">$PIDDIR</span></span><br><span class="line">    chown <span class="variable">$DAEMONUSER</span> <span class="variable">$PIDDIR</span></span><br><span class="line">    chgrp <span class="variable">$DAEMONUSER</span> <span class="variable">$PIDDIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! mountpoint -q /proc/ ; <span class="keyword">then</span></span><br><span class="line">    log_failure_msg <span class="string">&quot;Can&#x27;t start <span class="variable">$DESC</span> - /proc is not mounted&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$PIDFILE</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$0</span> status &gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">    log_success_msg <span class="string">&quot;<span class="variable">$DESC</span> already started; not starting.&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    log_success_msg <span class="string">&quot;Removing stale PID file <span class="variable">$PIDFILE</span>.&quot;</span></span><br><span class="line">    rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">create_machineid</span><br><span class="line"></span><br><span class="line">log_daemon_msg <span class="string">&quot;Starting <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">start-stop-daemon --start --quiet --pidfile <span class="variable">$PIDFILE</span> \</span><br><span class="line">    --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> -- --system <span class="variable">$PARAMS</span></span><br><span class="line">log_end_msg $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shut_it_down()</span><br><span class="line">&#123;</span><br><span class="line">log_daemon_msg <span class="string">&quot;Stopping <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">start-stop-daemon --stop --retry 5 --quiet --oknodo --pidfile <span class="variable">$PIDFILE</span> \</span><br><span class="line">    --user <span class="variable">$DAEMONUSER</span></span><br><span class="line"><span class="comment"># We no longer include these arguments so that start-stop-daemon</span></span><br><span class="line"><span class="comment"># can do its job even given that we may have been upgraded.</span></span><br><span class="line"><span class="comment"># We rely on the pidfile being sanely managed</span></span><br><span class="line"><span class="comment"># --exec $DAEMON -- --system $PARAMS</span></span><br><span class="line">log_end_msg $?</span><br><span class="line">rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload_it()</span><br><span class="line">&#123;</span><br><span class="line">create_machineid</span><br><span class="line">log_action_begin_msg <span class="string">&quot;Reloading <span class="variable">$DESC</span> config&quot;</span></span><br><span class="line">dbus-send --print-reply --system --<span class="built_in">type</span>=method_call \</span><br><span class="line">            --dest=org.freedesktop.DBus \</span><br><span class="line">            / org.freedesktop.DBus.ReloadConfig &gt; /dev/null</span><br><span class="line"><span class="comment"># hopefully this is enough time for dbus to reload it&#x27;s config file.</span></span><br><span class="line">log_action_end_msg $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start_it_up</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">    shut_it_down</span><br><span class="line">;;</span><br><span class="line">reload|force-reload)</span><br><span class="line">    reload_it</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">    shut_it_down</span><br><span class="line">    start_it_up</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">    status_of_proc -p <span class="variable">$PIDFILE</span> <span class="variable">$DAEMON</span> <span class="variable">$NAME</span> &amp;&amp; <span class="built_in">exit</span> 0 || <span class="built_in">exit</span> $?</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: /etc/init.d/<span class="variable">$NAME</span> &#123;start|stop|reload|restart|force-reload|status&#125;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p> 说明：实际上dbus的service，就是一个.sh脚本，如果有C或者sh的基础就很好弄懂是什么意思，比如<code>service dbus start</code>，service进程就会从<code>/etc/init.d/</code>目录下找到dbus这个服务，这个sh脚本的<code>case</code>参数传入<code>start</code>，调用具体的实现逻辑。</p>
<p> 再举一个简单点的例子，和实际用法。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVERNAME= <span class="string">&quot;DemonShell&quot;</span></span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;start <span class="variable">$SERVERNAME</span>&quot;</span></span><br><span class="line">    /home/mecry/DemonShell</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;start <span class="variable">$SERVERNAME</span> ok!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span>  0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;stop <span class="variable">$SERVERNAME</span>&quot;</span></span><br><span class="line">    killall <span class="variable">$SERVERNAME</span></span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;stop <span class="variable">$SERVERNAME</span> ok!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>  <span class="string">&quot;<span class="variable">$1</span>&quot;</span>  <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">restart)</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;usage: <span class="variable">$0</span> start|stop|restart&quot;</span></span><br><span class="line">    <span class="built_in">exit</span>  0;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p> 和上面的systemctl一样，<code>/home/mecry/DemonShell</code>是我脚本存放位置，开机控制其启动，调用service也可以控制启动和关闭此脚本，非常方便。</p>
</li>
</ol>
<h2 id="systemctl和service优点缺点"><a href="#systemctl和service优点缺点" class="headerlink" title="systemctl和service优点缺点"></a>systemctl和service优点缺点</h2><pre><code>建议使用systemctl，比较规范方便
</code></pre>
]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】博客搭建</title>
    <url>/2021/04/20/blog%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="blog的搭建"><a href="#blog的搭建" class="headerlink" title="blog的搭建"></a>blog的搭建</h1><p><em><strong>此博客是github，用hexo，并用使用next主题进行配置和搭建。</strong></em></p>
<span id="more"></span>

<p><strong>吐槽一下，作为一名纯种的后端搭建blog，尽管网上有说明，但是还是觉得有些许吃力。特别是我换顶部图片，简直是我一步一步试出来的</strong></p>
<p>搭建步骤</p>
<ul>
<li>注册一个github，并且新建一个名字一样的github仓库</li>
<li>配置本地的hexo环境</li>
<li>下载next主题</li>
<li>直接在<code>_posts</code>下开始写博客</li>
<li>大功告成</li>
</ul>
<p>注意：</p>
<h4 id="问题1：背景图片更换"><a href="#问题1：背景图片更换" class="headerlink" title="问题1：背景图片更换"></a>问题1：背景图片更换</h4><p>解决：在<code>main.styl</code>加入<code>@import &quot;_custom/styles.styl&quot;</code>，背景图片放在<code>themes\next\source\images</code>文件夹中，本地创建<code>themes\next\source\css\ _custom\style.styl</code>文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">background: url(<span class="regexp">/images/</span>图片名);</span><br><span class="line">background-repeat: no-repeat;<span class="comment">// 设定背景图片非重复填充</span></span><br><span class="line">background-attachment: fixed;<span class="comment">// 设置背景图片不随页面滚动</span></span><br><span class="line">background-position: <span class="number">50</span>% <span class="number">50</span>%;<span class="comment">// 设置背景图片位置</span></span><br><span class="line">background-size: cover<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题2：顶部图片更换"><a href="#问题2：顶部图片更换" class="headerlink" title="问题2：顶部图片更换"></a>问题2：顶部图片更换</h4><p>解决：在<code>headerband.styl</code>中插入下面那句话，背景图片放在站点的source/image下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.headband &#123;</span><br><span class="line">  <span class="comment">//background: $headband-bg;</span></span><br><span class="line">    background: url(<span class="string">&#x27;../../image/header-bg.jpg&#x27;</span>);</span><br><span class="line">  height: 180px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题3：文章置顶"><a href="#问题3：文章置顶" class="headerlink" title="问题3：文章置顶"></a>问题3：文章置顶</h4><p>解决：直接复制替换node_modules/hexo-generator-index/lib/generator.js的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    format: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>配置插件</p>
<p>$ npm uninstall hexo-generator-index –save</p>
<p>$ npm install hexo-generator-index-pin-top –save</p>
<p>然后在需要置顶的文章的Front-matter中加上top: true或者top数字top: 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">title: 置顶</span><br><span class="line">date: <span class="number">2019</span>-<span class="number">09</span>-<span class="number">09</span> <span class="number">09</span>:<span class="number">09</span>:<span class="number">09</span></span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">top: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>按照数字大小依次往下置顶排序</p>
<h4 id="问题4：博客提交"><a href="#问题4：博客提交" class="headerlink" title="问题4：博客提交"></a>问题4：博客提交</h4><p>解决：调用<code>blog_push.sh</code>是提交，<code>blog_localtest.sh</code>是在本地查看</p>
<h4 id="问题5：blog文章中图片添加"><a href="#问题5：blog文章中图片添加" class="headerlink" title="问题5：blog文章中图片添加"></a>问题5：blog文章中图片添加</h4><p>解决：在<code>_post</code>目录下创建一个同名文件夹，放图片，在文章中插入<code>![图1](1.png)</code>。</p>
<h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><ol>
<li>Node.js 安装，node在debian仓库只有10版本，hexo需要12以上参考<a href="https://github.com/nodesource/distributions/issues/1099">解决方案</a>,安装时必须在梯子环境下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_lts.x -o nodesource_setup.sh</span><br><span class="line">#将nodesource_setup.sh中 DISTRO&#x3D;$(lsb_release -c -s) 修改为 DISTRO&#x3D;stable</span><br><span class="line">sudo bash nodesource_setup.sh</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问题4：添加全屏背景并文章透明"><a href="#问题4：添加全屏背景并文章透明" class="headerlink" title="问题4：添加全屏背景并文章透明"></a>问题4：添加全屏背景并文章透明</h4><ol>
<li>在<code>hexo/source/images</code>下增加图片<code>background.jpg</code></li>
<li>在 <code>hexo/themes/hexo-theme-next/source/_data</code>下新建<code>styles.styl</code>文件，文件内容为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(&#x2F;images&#x2F;background.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    &#x2F;&#x2F; background-size: 100% 100%;</span><br><span class="line">    background-size: cover;</span><br><span class="line">    -webkit-background-size: cover;</span><br><span class="line">    -o-background-size: cover;</span><br><span class="line">    -moz-background-size: cover;</span><br><span class="line">    -ms-background-size: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;博客内容透明化</span><br><span class="line">&#x2F;&#x2F;文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line">.main-inner &#123; </span><br><span class="line">   &#x2F;&#x2F; margin-top: 60px;</span><br><span class="line">   &#x2F;&#x2F; padding: 60px 60px 60px 60px;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post-block &#123;</span><br><span class="line">    background: rgba(255,255,255,0.7) none repeat scroll !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sidebar-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.7) none repeat scroll !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
</search>
